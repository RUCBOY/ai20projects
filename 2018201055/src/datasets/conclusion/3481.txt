We have presented an efficient CUDA implementation of Feito and Torres’s point inclusion test that presents substantial execution-time improvements compared with the mono-threaded and multi-threaded CPU versions. We have explained how each algorithm step has been parallelized and optimized for its execution on the GPU. With our CUDA algorithm, a final average speedup of 114× is achieved with respect to the single-threaded CPU implementation; and an average speedup of 32× compared to a multi-threaded CPU version of the same point inclusion test. Currently, to our knowledge, there is no comparable GPU implementation of the point inclusion test except the one presented in [22]. In this case, our CUDA algorithm obtained a speedup of up to 11.88× against Rueda et al.’s CUDA algorithm, mainly due to the fact that our CUDA implementation avoids branching completely. Also, our CPU single-threaded algorithm achieved a speedup of up to 1.8× against the sequential CPU implementation of Rueda et al.’s algorithm.
The main limitation of our CUDA algorithm is that we cannot introduce it as the fastest GPU point inclusion test because it is outperformed by Li et al.’s GPU ray-shooting algorithm. That algorithm uses a spatial structure to avoid computing most ray-triangle intersections, which speeds up its execution considerably. Some work has been done to improve the inclusion test of Feito and Torres by using similar spatial representations [[8], [14]], however the pre-processing time needed to construct that spatial representation, the additional memory space it requires and the intrinsic logic of the algorithm based on it hinder its direct efficient implementation on GPU platforms. These limitations imply that further investigation is needed in order to take advantage of that kind of spatial structure to accelerate our CUDA algorithm. Nevertheless, compared to Li et al.’s algorithm our approach is more general since we can manage non-manifold meshes and also all special cases are efficiently and uniformly solved by the algorithm. Therefore, those applications which require dealing with all kinds of meshes in a robust way can benefit from our approach.
