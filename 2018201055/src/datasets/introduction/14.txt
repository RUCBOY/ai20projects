Lie derivatives play an important role in many mathematical and physical problems [1]. In particular, many methods in nonlinear control and system theory require the computation of Lie derivatives [2]. In this paper, we restrict our attention to the use of Lie derivatives in numerical methods for the solution of differential equations (1)y′(t)=f(y(t)),y(t0)=y0,where f:Rm→Rm,m≥1, is a Cl,l≥1, function on its domain and y0∈Rm is assigned. To get an intuitive understanding, Lie derivatives can be considered as total derivatives of certain fields along the solution of a differential equation. One of the main motivations for such an interest is the recent introduction of a class of multiderivative methods in the context of geometric integration [3], [4], [5]. When applied to canonical Hamiltonian problems, these methods have been shown to be conjugate-symplectic up to order p+2, where p denotes the order of convergence. This property makes them eligible for the numerical simulation of Hamiltonian problems over long times, provided that a reliable and efficient technique to compute the derivatives of the function f(y(t)) is available, where y(t) is implicitly defined by the differential problem itself (see (1)).
Two standard approaches to attack the problem of determining Lie derivatives in an automatic procedure make use of Symbolic Differentiation and Automatic Differentiation. The former exploits expression manipulation in computer algebra systems and is available in many problem solving environment such as Mathematica, Maxima, Maple and Matlab. Computer algebra software, however, could fail if the function is complicated and could not even be performed if an explicit analytic formulation of the function is not available at all.
In contrast, Automatic Differentiation (AD) can successfully operate also in the case where the function is defined through an algorithm implemented in a suitable programming language but would be useless if only a compiled version of the source code is available. AD refers to a family of techniques that compute derivatives through accumulation of values during code execution to generate derivative evaluations rather than derivative expressions. This, in general, allows estimations of derivatives whose accuracy is close to the underlying machine precision.
The website http://www.autodiff.org reports updated informations about papers and software available for AD. We refer to [6] for a survey on Automatic Differentiation in Machine Learning, and to [7] for a benchmark of selected algorithmic differentiation tools in the same field of research. Here the authors compare hand-derivative computation, finite differences, two symbolic differentiation tools, and 11 automatic differentiation tools written in different languages. The analysed problems are simple objective functions from computer vision and machine learning. Simple means that there are no iterative loops and conditional statements are encapsulated in functions such as abs, log, sum or exp. Many problems in machine learning are of this form because the objective function should be handled efficiently by the differentiation tool.
We stress that many of the existing computational platforms are not equipped with functions for computing Lie derivatives. One toolbox that allows the computation of Lie derivatives is ADOL-C, a c++ package for automatic differentiation of algorithms written in C/C++ [8], [9], [10].
Additional techniques are those based on dual numbers [11], [12] and hyperdual numbers theory [13], that allow the computation of the first derivative and of the second derivative respectively, and the ones based on complex and multicomplex numbers [14]. This latter can be used for computing derivatives of any order [14].
A framework that allows an automatic and easy computation of derivatives is provided by the Infinity Computer, a computational platform able to handle infinite and infinitesimal numbers and to execute operations on them. Interestingly, the differentiation tool devised inside this environment can successfully be applied even to black-box functions, namely functions whose analytical expression may be not accessed. In other words, the function f may be given by a code or formula which are unknown to the user. He/she provides an argument y and obtains a result f(y) without any knowledge about how this result has been obtained. As was emphasized above, in this case the user cannot calculate exact derivatives either analytically or symbolically (see [3], [15], [16], [17], [18]).
This tool has been theoretically analysed in [18] and extended to Lie derivatives in [15], [16], [17], [19] where Taylor methods for solving (1) have been proposed and in [3] where the class of multiderivative Euler–MacLaurin methods has been analysed.
The Infinity Computer is based upon a positional numeral system with the infinite radix ① (called grossone) representing the number of elements of the set of natural numbers N. For a complete description of the related theory we refer the reader to [20], [21], [22], [23], [24].
A number C in this system, called grossnumber, is a linear combination of powers of ① of the form (2)C=cpm①pm+⋯+cp1①p1+cp0①p0+cp−1①p−1+⋯+cp−l①p−l,where all numerals ci≠0 belong to a traditional numeral system and are called grossdigits, while numerals pi, that may be finite, infinitesimal or infinite, are sorted in the decreasing order pm>pm−1>⋯>p1>p0>p−1>⋯p−(l−1)>p−l,with p0=0 and called grosspowers. A grossnumber has a finite part if the grossdigit associated with the grosspower p0 is different from zero (see [24], [25] and the patents [26] for details).
Terms having finite positive grosspowers represent the simplest infinite parts of C. Analogously, terms having negative finite grosspowers represent the simplest infinitesimal parts of C. For example, the number C1=2①−1+3.54①−2 represents only infinitesimal parts, the number C2=−5.34⋅10−3①2+2.77⋅105①1 represents only infinite parts, while their sum C3=C2+C1=−5.34⋅10−3①2+2.77⋅105①1+2①−1+3.54①−2 brings both infinite and infinitesimal quantities. A number is called purely finite if it does not contain infinitesimal parts. Hereinafter, for the sake of simplicity, we will call these numbers just finite. In positional notation, a grossnumber takes the form C=cpm①pm…cp1①p1cp0①p0cp−1①p−1…cp−l①p−l.So, for example, the number C3 is represented as C3=(−5.34⋅10−3)①22.77⋅105①12①−13.54①−2.
As we will see, for the computation of the derivative, the simplest grossnumber used is ①−1, which corresponds to evaluate the Lie derivative using forward finite difference with an infinitesimal step.
Besides the computation of derivatives, the ①-based methodology has been successfully applied in several areas of Mathematics and Computer Science: e.g., in optimization (see [27], [28], [29], [30], [31], [32], [33]) and going through infinite series (see, e.g., [24], [34]), in modelling and numerical simulation [3], [15], [35], [36], fractals and cellular automata (see [37], [38]), the first Hilbert problem and Turing machines (see [24], [39]), infinite decision making processes, game theory, and probability (see [40], [41], [42], [43]), etc.
The paper is organized as follows. In Section 2, we give a brief review about the technique used for the computation of standard derivatives of a function y(t) using the Infinity Computer. Section 3 focuses on the computation of Lie derivatives, and a new technique is introduced and analysed. Finally, in Section 4, the techniques presented are compared with algorithms based on symbolic differentiation and automatic differentiation using Matlab.
