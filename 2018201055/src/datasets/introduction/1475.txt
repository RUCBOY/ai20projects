Trees are one of the fundamental data structures used in Computer Science and the theory of formal tree languages has been extensively studied and developed since the 1960s [16] (with more recent version [18]) and [12], [17]. Tree pattern matching on node-labelled trees is an important algorithmic problem with applications in many tasks such as compiler code selection, interpretation of nonprocedural languages, implementation of rewriting systems, or XML processing. Tree patterns are trees whose leaves can be labelled by a special wildcard, the nullary symbol S, which serves as a placeholder for any subtree. Since the linear notation of a subtree of a tree is a substring of the linear notation of that tree, the subtree matching and tree pattern matching problems are in many ways similar to the string pattern matching problem. However, linear notations of trees are generated by context-free grammars while strings are generated by regular grammars. Furthermore, we note that the tree pattern matching problem is more complex than the string matching one because there can be at most n2 distinct substrings of a string of size n, whereas there can be at most 2n−1+n distinct tree patterns which match a tree of size n.
As mentioned, trees can be linearised into strings. Such a linear notation can be obtained by a corresponding tree traversal. Moreover, every sequential algorithm on a tree traverses its nodes in a sequential order, which corresponds to some linear notation. Such a linear representation needs not be built explicitly. Many algorithms have been proposed for exact string matching [4], [13], [14], [23]. Among the most efficient of them are those based on backward string pattern matching, represented by the Boyer-Moore and Boyer-Moore-Horspool algorithms. Although backward string pattern matching's time complexity is generally O(n×m) (for text and pattern of size n and m respectively) in the worst case, due to such algorithms' ability to skip text parts, the best case is Ω(n/m). The Boyer-Moore-Horspool algorithm performs linearly on average, with the linearity constant proven to be asymptotically α, 1/c≤α≤2/(c+1), where c is the cardinality of the alphabet [3]. Note that α≤1 for any c, hence the number of comparisons performed by the algorithm is sublinear on average. For surveys on string matching algorithms see [4], [13], [14], [23] and taxonomy of sublinear string pattern matching algorithms see [9], [8].
Many tree pattern matching algorithms exist as well [5], [7], [15], [19] and many of them use some kind of tree automata [7]. Cole et al. [10] use a subset matching approach, but at the cost of large auxiliary data structures. For unrestricted tree pattern sets, among the fastest algorithms in practice are algorithms based on deterministic frontier-to-root (bottom-up) tree automata (DFRTAs) [5], [7], [19] and Hoffmann-O'Donnell-style stringpath matchers [1], [19]. A few of these tree pattern matching algorithms use principles of matching patterns backwards: Hoffmann and O'Donnell refer to work by Lang et al. [22] that applies such an approach to leftmost stringpaths of trees which involves complications when dealing with nodes of arity greater than 2. Another tree pattern matching algorithm was introduced in [26], where symbols of a tree pattern and string paths of an input subject tree are compared. The shifting is based on an extension of the Boyer-Moore style of shifting for more patterns introduced in [11]. This algorithm can skip nodes of the subject tree when it is known that no occurrence of the pattern is skipped.
While modifying backward string pattern matching to backward subtree matching (searching for occurrences of given subtrees) is straightforward, this is not the case for backward tree pattern matching, where complications arise due to the use of wildcard symbol S and matched subtrees being possibly recursively nested. In this paper, a new backward tree pattern matching algorithm is presented. The presented backward tree pattern matching algorithm preserves the properties and the advantages of the standard backward string pattern matching: most importantly the number of symbol comparisons in the backward tree pattern matching can be sublinear in n, the size of the subject tree. Based on the Boyer-Moore-Horspool algorithm, a modified bad character shift heuristic is used. As in the case of backward string pattern matching, the size of the bad character shift table used by the algorithm is linear with the size of the alphabet. Our experimental results confirm the properties of the algorithm and show that it outperforms the aforementioned DFRTAs and stringpath matchers.
The paper is an extension of conference paper [25]. The backward tree pattern matching algorithm described in Section 3 is the core of the original paper. Later sections introduce various modifications to the original algorithm mainly to apply to different linear notations of trees.
