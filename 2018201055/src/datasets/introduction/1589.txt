Database theory, pattern matching, computational learning theory, formal language theory—in these and other subfields of computer science a set L of strings is often represented by some string expression that “matches” all the strings in L. Regular expressions (as well as variants of regular expressions) are perhaps the most prominent such type of expression, but another kind of expression of relevance to many applications is the pattern. A pattern π is a finite string of constant symbols (often called terminal symbols) and variables, where the constant symbols are taken from some alphabet Σ. A string w over Σ matches π (or π matches w) if w can be obtained by substituting the variables in π with finite strings over Σ; the language of π, denoted L(π), is then the set of all strings matching π. Angluin's original definition of pattern languages [1] required that no variable be erased, i.e., substituted by the empty string, when matching a string; the corresponding pattern languages are hence called non-erasing pattern languages. In this paper, we study the case of so-called erasing or extended pattern languages [28], where substitutions with the empty string are allowed. For example, the pattern ax1x1abx2 over Σ={a,b} matches all strings starting with the symbol a, followed by a (possibly empty) square and the string ab, and ending in any (possibly empty) suffix. Unless stated otherwise, we will use the term “pattern languages” to refer to erasing pattern languages.
Several fundamental problems on pattern languages have been addressed in the literature pertinent to learning theory, as they are of relevance to the design of learning methods that identify pattern languages from examples or from queries. For instance, the membership problem, i.e., to decide whether a given pattern matches a given string, is NP-complete [18], and only a few interesting special cases are known in which it has a polynomial-time solution [5]. Worse yet, the inclusion problem, to decide whether one given pattern generates a language contained in that of another, is undecidable [7]. A prominent open question concerns the problem to decide whether two given patterns generate the same language, known as the equivalence problem. To date, it is not known whether this problem is decidable; notable decidable special cases were published around 20 years ago [18], [22], but rather limited progress has been made on this problem since, cf. [7] for a discussion.
The focus of this paper is on the following decision problem, which we call the finite distinguishability problem: is a given pattern π finitely distinguishable (w.r.t. the class of all patterns), i.e., are there finite sets T+ and T− of strings such that L(π) is the only pattern language that contains all of the strings in T+ and none of the strings in T−? This problem is of relevance to computational learning theory as well as to formal language theory; previously it has been studied in computational biology [3] and in a recursion-theoretic context [2]. For the non-erasing case, the problem is trivial since every pattern is finitely distinguishable w.r.t. the class of all patterns [1]. As it turns out, the erasing case is more complex.
In computational learning theory, finite distinguishability is equal to the property that L(π) has a finite teaching set w.r.t. the class of all pattern languages. A teaching set T for a language L w.r.t. a class L containing L is a set of strings, each labelled either + or −, such that L is the only language in L that contains all the +-labelled and none of the −-labelled strings in T. The size of a smallest teaching set is a lower bound on the number of labelled strings a learning algorithm would require to exactly identify L within L [14], [26].
From a language-theoretic point of view, the finite distinguishability problem is interesting in its own right, since the structure of teaching sets reveals structural properties of language classes. In the context of pattern languages in particular, there is another potential benefit of studying the finite distinguishability problem, due to its relevance to the unsolved equivalence problem. Firstly, if a pattern π is finitely distinguishable as witnessed by sets T+ and T− that can be algorithmically derived from π, then the problem of equivalence of π to any other pattern π′ is decidable: it suffices to test whether π′ matches all strings in T+ and no strings in T−. Secondly, if neither of two patterns π, π′ is finitely distinguishable, then we know that a procedure deciding the equivalence problem on the instance (π,π′) cannot solely rely on membership testing using the entire teaching set of either π or π′.
Our contributions are as follows: (i) We show that the finite distinguishability problem is decidable for the whole class of pattern languages as well as for the class of k-variable constant-free pattern languages (for any fixed k) over all alphabet sizes other than 2 and 3. In doing so, we reveal some connections to the problem of deciding whether a pattern generates a regular language, which has previously been proven decidable for alphabet sizes other than 2 and 3 [17]. (ii) For alphabet sizes 2 and 3, we provide partial results, again aligning with the existing literature on regular languages generated by patterns [25]. (iii) We study variants of the finite distinguishability problem, namely, the question whether a pattern in class Π is finitely distinguishable from all patterns in class Π, for subclasses Π of the class of all patterns over a fixed alphabet. It turns out that this problem is decidable for the well-known classes of regular patterns and non-cross patterns.1 Furthermore, for each of these classes, we prove that any finitely distinguishable pattern π has a teaching set of size polynomial in the length of π (linear for regular patterns, while for non-cross patterns there is only one pattern, up to equivalence, with finite distinguishability). We also show that for the class of 1-variable patterns, any finitely distinguishable pattern π has a teaching set of size O(|π|2|π|). (iv) Due to the links to computational learning theory, we further explore the worst-case complexity of teaching pattern languages in two popular models of computational teaching, namely the teaching dimension model [14], [26] and the recursive teaching dimension model [30], thus complementing an earlier such study on non-erasing pattern languages [8].
Most of our proofs establishing the finite distinguishability of some form of patterns are constructive in that they provide effectively constructed finite teaching sets rather than just proving their existence. They are thus meaningful for the design of strategies for algorithmic teaching and learning.
