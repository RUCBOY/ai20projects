Interval arithmetic [1], [2] is a reliable method for numerical computation that deals with reals. It handles (machine-representable) intervals instead of numerical values, typically floating-point (FP) numbers, and evaluates arithmetic expressions via computing their interval enclosures with careful control of rounding modes and interval widening. The four elementary arithmetic operators on intervals can be implemented in an efficient way that only considers the bounds of the given argument intervals. However, actual implementations need to make a large case analysis that considers, e.g., magnitude relations between all pairs of argument bounds, positional relations between the arguments and zero, and handling of the special values, ±∞ and NaN. For instance, the implementation of the multiplication in the kv library [3] comprises 13 branches. As existing code bases are implemented by human hands, their correctness is not obvious, which comes to be critical for the reliability.
In this work, we use Why3 to prove the correctness of the code. Why3 [4], [5] has been developed as a program verification platform, which integrates automated theorem provers (e.g. SMT solvers) and interactive proof assistants (e.g. Coq). Why3 provides a specification language WhyML to describe a target program and to annotate the program with meta-level properties. Given a specification, Why3 generates verification conditions (VCs) that ensure the correctness when they are all validated. Users can then apply the back-end provers in succession to discharge all of the VCs. Targets of Why3 include numerical programs and several applications have been reported (e.g. [6]), as support for the numerical domain has been developed both in the platform and its back-end provers.
This study aims for the verification of the four interval arithmetic operations, i.e., addition, subtraction, multiplication and division. For this purpose, we translate an implementation into WhyML and properly annotate the preconditions and postconditions. For the generated VCs, we experiment with discharging them via utilizing back-end provers, Alt-Ergo [7] and Coq. Although the control structure of the implementation is simple, which only consists of branching statements, proof obligation becomes complicated due to combinations of FP number expressions and the axioms that realize the system of FP numbers/intervals in Why3. Several VCs thus remain unproved after a basic usage of Why3. Therefore, we examine the target annotated code and propose techniques to complete the verification. Finally, we show that the entire annotated code is verified and present experimental measures such as timings.
1.1. ContributionThis contribution is a mechanical proof of an implementation of the four operators, which verifies mainly three properties: validity (“the results conform to the definition of intervals”), soundness (“the results enclose every possible real values”) and tightness (“the resulting enclosures are optimal/tightest”). Our verification result indicates that the operators, which compute with the bounds of operand intervals and return the hull of computed results, satisfy the three properties.To complete the proof, we propose several techniques to specify/verify the target interval operations and their properties. First, through an examination of each unproved VC, we find that specifying an additional lemma will help the Alt-Ergo SMT solver to discharge the VC. For instance, for a VC on FP numbers, a lemma on reals involving the same expression as the VC may help to discharge it. We identify 19 lemmas needed for the complete verification. Second, we propose a specification of the tightness property of an interval computation such that the code annotated with the property is verified by SMT solvers. In this specification, it is essential to reformulate the interval hull operation with a consideration of NaN.We note that the target of above techniques is not limited to interval arithmetic operations but applicable to various proof tasks in the numerical domain, e.g., verification of other interval functions and application programs.
1.2. OutlineSection 2 introduces basic notions and concepts of interval arithmetic. Section 3 explains the main tools for verification: Why3 and Alt-Ergo. The following sections describe the main verification process for an interval arithmetic code. First, Section 4 gives an overview of the process. Second, Section 5 explains the specification of the target code. Next, Sections 6 Validity and soundness of multiplication, 7 Tightness of multiplication describe the processes of annotating the pre- and postconditions to the code and discharging the generated proof obligations. Section 8 reports the complete results of the verification experiment.
