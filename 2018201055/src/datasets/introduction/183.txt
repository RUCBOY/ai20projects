Since there exists a wide range of mathematical formulas and their implementations, in the context of this paper, we use the term formula code to denote fragments of source code that compute a numerical value (scalar, vector, matrix) in a way that can be expressed in a common mathematical notation (Cajori, 1929) or by a mixed form of source code artifacts and maths symbols.
The correct and performant implementation of mathematical aspects is a crucial part influencing the success of a software system. The destruction of the Mariner 1 spacecraft in 1962 caused a $18.5 million financial damage due to a faulty implementation of a mathematical formula in FORTRAN, in particular a missing superscript bar ‘signifying a smoothing function, so the formula should have calculated the smoothed value of the time derivative of a radius’ (Lake, 2010, Leech and Klaes, 2017, Moore, 1987). This is only one prominent example where formula code happens to be a critical part of a software system. An incident during Qantas Flight 72 in 2008 shows that it is often not the formula implementation alone that may cause potentially catastrophic outcomes, but the assumptions being made when specifying the intended behavior. On that flight, the way in which the Airbus A330-300’s flight control computer determined an important flight parameter based on the average and median values of three sensor outputs plus a combination of heuristics to deal with spike values caused the airplane to enter a steep descent, injuring passengers and crew members (Australian Transport Safety Bureau, 2020).
The general discipline of software engineering is studded with problem solving and therefore with mathematical reasoning (Henderson, 2003). Thus maths is omnipresent in the work of a software engineer and represented in the software systems’ code base by the utilization of one or more programming languages. Furthermore, the early detection of defects in maths implementations and discovery of opportunities to increase the software’s performance within the development of a software system could save hours of testing and consumption of resources, especially in long running computational environments, such as scientific or high performance computing. Software development tools supporting the implementation and comprehension of formula code would not only be of advantage in such specialized scientific domains. To some extent every computer program contains at least some logic or discrete mathematics like combinatorics, probability theory, graph theory or number theory.
In psychological studies Landy et al. investigated the importance of spatial relationships in mathematical notations (Landy et al., 2014). For example, test persons falsely rated the equation a+b∗c+d=c+d∗a+b valid, if the distance between symbols did not correspond to the operator precedence. The authors concluded ‘that competent symbolic reasoners typically rely on semantically irrelevant properties of notational formulae in order to quickly and accurately – but also sometimes inaccurately – solve symbolic reasoning problems.’ Thus, we assume that a mathematical representation is beneficial in order to reduce both the time for comprehending the code as well as assessing its correctness. In mathematical notation, operators and symbols are arranged in two dimensions allowing a more compact view.
When we started this project, we found ourselves in the situation that we could not find much work to build on. Surprisingly, although mathematical formulas obviously play an important role in programming, so far, software engineering research has not empirically studied the implementation of formulas in common programming languages nor developed much tool support for implementing, debugging and optimizing formulas. Research as well as tools have rather focused on different levels of program abstractions (e.g. statement, class, or package level) or on higher-level abstractions (e.g. features, aspects, or components). In general purpose programming languages such as Java, Python or C++, formula code does not simply correspond to a syntactical category such as expression: Not all expressions in a program implement a formula (e.g. fopen(fname)!=-1) and not all formulas are implemented as expressions (e.g. program code for ∑i=1nai typically uses for-loops). Identifying formula code and making software developers aware of recurring patterns, best practices, pitfalls, and useful ‘hacks’ related to the implementation of mathematical aspects as well as simply showing the code in maths like notation can help to reduce development time and technical risk, as well as the effort for code comprehension and communication, particularly in cross disciplinary development teams, where experts of mathematically predominant domains, e.g. mathematicians or chemical scientists, and software developers tightly work together.
Our vision is that better understanding of the characteristics of formula code will help to develop novel tools, beyond formula editors, for understanding, maintaining, debugging and optimizing formula code as well as to design new APIs and language features to enhance a software systems maintainability and thus its overall code quality.
To gain insights on the use of formula code in real software projects and as a basis for future research on tool support and language design, we want to answer the following two research questions:

RQ1 (Diversity):What kinds of formula code occur in real-world software projects?RQ2 (Frequency):How frequent is formula code both at file and line granularity?
To answer these research questions, we performed two studies, one qualitative and one quantitative study. For our qualitative study, we ran a keyword-based search to find formula code in open source Java projects on GitHub (Section 3). While this keyword-based approach suffers both from low recall and low precision and requires a lot of manual post-processing, it helped us to find an initial set of real-world formula code samples, that we then manually analyzed in order to gain first insights on the kinds of formula code that exist (RQ1) and to derive patterns of formula code (Section 4).
While there exist programming languages such as FORTRAN or MATLAB that are tailored for numerical computation, even in those languages there exists a conceptual gap between imperative language features and the declarative nature of mathematical formulas. Nevertheless, imperative languages such as Ada are still commonly used to implement mathematical formulas, for example in the aviation industry (Ada Information Clearing House, 2020, Aviation Week, 2020). However, mathematical formulas do not only play a role in safety-critical domains like aviation, they are also central to many concepts in computer graphics, machine learning or finance. We decided to focus on a general-purpose programming language, Java, because not having direct support for implementing mathematical formulas, for example by having a matrix datatype and related operations, adds an additional indirection layer that makes it even harder for developers who need to implement mathematical formulas in such languages. Our study has shown that, while relatively rare, mathematical formulas are being implemented in Java. In some of our sampled projects more than 5% of source code implemented a sum or product formula and every 4th loop in the scientific computing projects implemented such a formula.
Given the diversity of the formulas that we found, we decided to focus on sum and product formulas for our quantitative analysis, because they are structurally non-trivial and we expected them to occur quite frequently. We will use the term SP-formulas in the rest of this paper to refer to sum and product formulas and the term SP-formula code to refer to source code we can express as SP-formulas in a mathematical notation. The derived patterns from the quantitative study form the basis of our pattern-based method for detecting SP-formula code (Section 5.1). Our approach is not only able to classify source code as SP-formula code, but also to reconstruct the formula implemented by the code in mathematical notation. Our evaluation shows that the pattern-based method has a very high precision (almost 100%) and a modest recall (31%) for SP-formula code. Moreover, for 85% of the detected SP-formula code the reconstructed formula was both correct and completely described the computation of the matched code. Finally, to answer research question RQ2, we applied the tool on a sample of 1000 different open source Java projects to detect SP-formula code on GitHub (Section 5). For a smaller sample, we also compared the densities from arbitrary application domains with those in scientific computing.
Furthermore, to assess the need for tool support related to formula code, we performed two small studies. First, we investigated the source-code comments of 139 real-world formula code fragments and observed that they are rarely commented in a way that helped to better comprehend the implemented formula. Second, in an online survey, we examined whether showing a reconstructed mathematical formula next to the formula code supports the defect detection task. For the survey we selected four real-world formula code fragments of different complexity. Due to the low number of participants that actually completed the survey, the quantitative results comparing their performance with and without showing the reconstructed formula are not conclusive. However, for complex formulas the accuracy scores considerably decreased, which offers ample room for tool development. This adds to our assumption that tools can improve development tasks related to formula code. Moreover, the vast majority of the participants found a tool that reconstructs the mathematical formula from the source code as helpful.
In summary our contributions are: A first qualitative study investigating the nature of formula code; a set of recurring formula code patterns derived from the findings in the qualitative study; a quantitative study on the density of sum and product formula code in open source Java projects.
