Nowadays, post-production techniques in visual effects are widely used in video visual effects for the modern filmmaking industry. Image morphing creates special effects by smoothing a transition from one image to another [1]. Image inpainting removes unwanted objects in video and then provides regional reconstruction for that object [2]. Motion tracking, such as facial motion tracking, can be used for digital makeup and for transferring facial expressions from one actor to another [3]. Image matting separates a foreground object from its background, so the separated foreground object can be moved and collated into other scenes. In contrast to matting object from any background, chroma key or blue/green screen is the simplest kind of image matting where green or blue is the background as it is nothing like human skin tone, thus making it easier to extract human actors as foreground objects. Making a man walk on the surface of water is an example of this special effect.
Image matting has been an essential technique in computer vision, as it can also be applied to perform image dehazing [4], [5], image deblurring [6], [7], and object tracking [8], [9], [10]. Given an Image I, a matting technique aims to estimate an optimal linear combination of a foreground F and a background B, along with opacity or alpha mask α
∈ [0, 1], such that (1)I=αF+(1−α)B
For a given image I, we need to obtain F, B and α of the image. Since all variables on the right-hand side of Eq. (1) are unknown, we need more information from user feedback to decrease the area of the unknown region to reduce the amount of computation required. In most cases, we need a trimap or a scribble. A trimap is an image specified by the user to indicate the actual foreground and background regions and a rough indication of the unknown region; whereas a user creates a scribble via application of different color brushes painted roughly through the object and background-position interactively. With this information, foreground, background, and unknown regions are estimated. The computation time depends on the number of pixels in the unknown region to be solved. Thus, the goal of the matting algorithm is to get all these three values of αi, Fi, Bi for an ith pixel in an unknown region U.
Particularly in this research, we focus on the parallelization and modernization of Sharing Sampling Alpha Matting (SSAM) algorithm [11], as well as a detailed analysis of the matting approach. OpenMP [12] has been widely used as an application programming interface that supports multi-platform shared-memory multi-processing programming, and its performance depends on the ability to scale with the number of cores used in a calculation to achieve higher speedup [13]. Henceforth, OpenMP is chosen to port the sequential SSAM program due to its portability, incremental parallelization, and ease of use.
Code modernization is a new paradigm for the migration of legacy code to fully exploit the capabilities of the new system such that the performance can scale with core count. It can take significant efforts, depending on the level of optimization required. We usually hope modernization can be done quickly with fewer attempts, and the resulting code can be easily maintained and can fully utilize the features of modern computer architectures. In the modernization of the Shared Image Matting code, we find that it takes tremendous effort to customize the code to the parallel system, even without considering the highest optimization. Even though OpenMP is easy to use, it does not mean that everything is straightforwardly parallelizable, especially when there are loops that contain (1) many variables needing proper declaration as shared, private, first private, last private, or thread private; (2) multi-level nested loops; (3) loop-carried data dependence that causes sequential coding; (4) data structures such as array indirect reference, iterator, stack, queue, pointers, and aliases which can cause data dependencies; (5) significant numbers of nested conditional statements which may hinder vectorization; and (6) goto, exit and return statements which may cause a non-block-structured code, where OpenMP only allows block-structure within the loop.
Overall, the contributions of this paper can be summarized as the following:

–A modernized and optimized implementation of a sequential algorithm of Alpha Matting based on shared matting is presented, where most code has been parallelized by OpenMP work sharing with SIMD vectorization constructs, providing significant improvements for high-resolution images;–The performance improvements we achieved make it capable of being used in real-time applications;–Our experience on the parallelization of a sequential code using OpenMP is presented, which we hope can serve as a reference design for software developers when developing parallel applications.
