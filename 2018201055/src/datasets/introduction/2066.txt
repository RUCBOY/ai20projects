Simulating universal quantum computers on conventional, classical digital computers is a great challenge. Increasing the number of qubits (denoted by N) of the quantum computer by one requires a doubling of the amount of memory of the digital computer. For instance, to accurately simulate the operation of a universal quantum computer with 45 qubits, one needs a digital computer with slightly more than 1/2 Petabytes (1015∕2 bytes) of memory. There are only a few digital computers in the world which have the amount of memory, number of compute nodes, and a sufficiently powerful network connecting all the compute nodes to perform such simulations. Performing computations with such a large amount of memory and processors requires a simulator that can efficiently use the parallel architecture of present day supercomputers.
We report on novel algorithms and techniques implemented in the Jülich universal quantum computer simulator (JUQCS). In this paper, “universal quantum computer” refers to the theoretical, pen-and-paper, gate-based model of a quantum computer [1] in which the time evolution of the machine is defined in terms of a sequence of simple, sparse unitary matrices, with no reference to the real time evolution of a physical system. An article about an earlier version of the same simulator was published in this journal eleven years ago [2]. Since then, supercomputer hardware has evolved significantly and therefore we thought it was time to review and improve the computationally critical parts of the simulator and use it to benchmark some of the most powerful supercomputers that are operational today. In Table 1 we collect the main characteristics of the computer systems that we have used for our benchmarks.
JUQCS runs on digital computers ranging from personal computers to the largest supercomputers that are available today. The present version of the simulator comes in two flavors. One version, referred to as JUQCS-E (E referring to numerically exact, see below), uses double precision (8-byte) floating point arithmetic and has been used to simulate a universal quantum computer with up to 45 qubits. The 45 qubit limit is set by the amount of RAM memory available on the supercomputers that we have access to, see Table 1. For a system of N qubits and using 16 bytes per complex coefficient of the 2N different basis states, the amount of memory required to store the wave function is 2N+4, i.e., 1∕2 PB are needed to store the wave function of N=45 qubits. Adding storage for communication buffers (default is to use 2N−3 bytes) and an insignificant amount of bytes for the code itself, simulating a N=45 qubit universal quantum computer requires a little more than 1∕2 PB but certainly less than 1 PB of RAM memory.Table 1. Overview of the computer systems used for benchmarking. The IBM Blue Gene/Q JUQUEEN [3] (decommissioned), JURECA [4] and JUWELS are located at the Jülich Supercomputing Center in Germany, the K computer of the RIKEN Center for Computational Science in Kobe, Japan, and the Sunway TaihuLight [5] at the National Supercomputer Center in Wuxi, China. The row “# qubits” gives the maximum number of qubits N that can be simulated with JUQCS-A (JUQCS-E). At the time of running the benchmarks on JUWELS, the maximum number of qubits N was limited to 43 (40)JUQUEENK computerSunway TaihuLightJURECA-CLUSTERJUWELSCPUIBM PowerPCeight-core SPARC64SW26010 manycoreIntel XeonDual Intel XeonA2VIIIfx64-bit RISCE5-2680 v3Platinum 8168clock frequency1.6 GHz2.0 Ghz1.45 GHz2.5 GHz2.7 GHzmemory/node16 GB16 GB32 GB128 GB96 GB# threads/core used1 – 2811 – 21 – 2# cores used1 – 2621442 – 655361 – 1310721 – 61441 – 98304# nodes used1 – 163842 – 655361 – 327681 – 2561 – 2048# MPI processes used1 – 5242882 – 655361 – 1310721 – 10241 – 2048# qubits46 (43)48 (45)48 (45)43 (40)46 (43)
A second version, referred to as JUQCS-A (A referring to approximate), trades memory for CPU time and can be used to simulate a universal quantum computer with up to 48 qubits on digital computers with less than 1 PB of RAM memory, with a somewhat reduced numerical precision relative to the other version of the simulator. JUQCS-A employs adaptive coding to represent the quantum state in terms of 2-byte numbers, effectively reducing the memory requirements by a factor of eight relative to the one of JUQCS-E (see Section 4.1 for more details). The adaptive coding requires additional computation such that for some of the quantum gates, JUQCS-A takes a longer time to complete than JUQCS-E. The reduced precision (about 3 digits) has been found more than sufficient for all quantum circuits that have been tested so far.
From the quantum computer user perspective, JUQCS-E and JUQCS-A are fully compatible. In this document, the acronym JUQCS refers to both versions while JUQCS-E and JUQCS-A are used specifically to refer to the numerically exact version and the adaptive-coding version of the simulator, respectively. The only difference, if any, between JUQCS-E and JUQCS-A is in the accuracy of the results.
A quantum gate circuit for a universal quantum computer is a representation of a sequence of matrix–vector operations involving matrices that are extremely sparse. Only a few arithmetic operations are required to update one coefficient of the wave function. Therefore, in practice, simulating universal quantum computers is rather simple as long as there is no need to use distributed memory or many cores and the access to the shared memory is sufficiently fast [6], [7], [8], [9]. The elapsed time it takes to perform such operations is mainly limited by the bandwidth to (cache) memory. However, for a large number of qubits, the only viable way to alleviate the memory access problem is to use distributed memory, which comes at the expense of overhead due to communication between nodes, each of which can have several cores that share the memory (as is the case on all machines listed in Table 1). Evidently, the key is to reduce this overhead by minimizing the transfer of data between nodes, which is exactly what JUQCS does [2].
Another road to circumvent the memory bottleneck is to use the well-known fact that propagators involving two-body interactions (two qubits in the case at hand) can be replaced by single-particle propagators by means of a Hubbard–Stratonovich transformation, that is by introducing auxiliary fields. A discrete version of this trick proved to be very useful in quantum Monte Carlo simulations of interacting fermions [10]. In Section 4, we show that the same trick can be used in the present context to great advantage as well, provided that the number of two-qubit gates is not too large and that it is sufficient to compute only a small fraction of the matrix elements between basis states and the final state. The latter condition considerably reduces the usefulness of this approach because for an algorithm such as Shor’s, it is a-priori unknown which of the basis states will be of interest. Nevertheless, this trick of trading memory for CPU time is interesting in itself and has recently been used, in various forms and apparently without recognizing the relation to the auxiliary field approach to many-body physics, to simulate large random circuits with low depth [11], [12], [13], [14].
JUQCS is a revised and extended version of the simulator, written in Fortran, developed about eleven years ago [2]. Depending on the hardware, the source code can be compiled to make use of OpenMP, the Message Passing Interface (MPI), or a combination of both. Apart from a few technical improvements, the “complicated” part of the simulator, i.e. the MPI communication scheme, is based on the same approach as the one introduced eleven years ago [2]. JUQCS-E and JUQCS-A use the same MPI communication scheme. During the revision, we have taken the opportunity to add some new elementary operations for implementing error-correction schemes and a translator that accepts circuits expressed in OpenQASM, i.e., the language used by the IBM Q Experience [15], [16]. The executable code of JUQCS has been built using a variety of Fortran compilers such as Intel’s ifort, GNU’s gfortran, IBM’s XLF, and others. Using JUQCS-A (JUQCS-E), a notebook with 16GB of memory can readily simulate a universal quantum computer with 32 (29) qubits. Since portability is an important design objective, we have not engaged in optimizing the code on the level of machine-specific programming to make use of, e.g., the accelerator hardware in the Sunway TaihuLight. We leave this endeavor to future work.
A JUQCS program looks very much like a conventional assembler program, a sequence of mnemonics with a short list of arguments. JUQCS converts a quantum circuit into a form that is suitable as input for the simulation of the real-time dynamics of physical qubit models, such as NMR quantum computing [17] using the massively-parallel quantum spin dynamics simulator SPI12MPI [6], or quantum computer hardware based on superconducting circuits [18]. A description of the instruction set that JUQCS accepts is given in Appendix A.
The primary design objective of the original JUQCS simulator [2] was to provide an environment for testing and optimizing the MPI communication part of SPI12MPI. The efficient simulation of spin-1/2 models (e.g. physical models of quantum computers) requires elementary operations that are significantly more complex than those typically used in universal quantum computation [6]. Therefore, to test the MPI communication part properly, JUQCS does not exploit the special structure of the CNOT and the Toffoli gate and also does not modify the input circuit using quantum gate circuit optimization techniques.
JUQCS is found to scale very well as a function of the number of compute nodes, beating the exponential growth in time that is characteristic for simulating universal quantum computers [1]. Such simulations can be very demanding in terms of processing power, memory usage, and network communication. Therefore, JUQCS can also serve as a benchmark tool for supercomputers. We cover this aspect by reporting weak scaling plots obtained by running quantum algorithms on the supercomputers listed in Table 1.
The paper is structured as follows. In Section 2, we briefly review the basics of gate-based universal quantum computing, emphasizing the aspects which are important for the design of a simulator. Section 3 addresses techniques for distributing the workload of a simulation over many compute cores. The primary bottleneck of simulating a gate-based universal quantum computer is the amount of memory required to store the wave function representing the quantum state of the machine. Section 4 discusses two very different methods for alleviating this problem. In Section 5, we present results obtained by executing a variety of quantum circuits on JUQCS, running on five different supercomputers. Conclusions are given in Section 6.
