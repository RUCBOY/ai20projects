Computation is everywhere around us (Moore and Mertens, 2011, Rich, 2008) and is central to life on Earth. Computation takes place not only in the myriad of electronic devices we use daily but also in living systems. In life, biochemistry implements computation via the chemical properties of “organic” matter (Conrad, 1972, Katz, 2012), i.e., using chemical support: inputs are chemical substances, the mechanical processing occurs via chemical reaction mechanisms, and the result is chemical before its transduction into specific functionalities, chemical or otherwise.
More specifically, a computation is (Rich, 2008, Katz, 2012) the process by which information in sequences belonging to a language and consisting of “symbols” in an alphabet are fed to a computing device (“automaton”) that recognizes the symbols and is endowed with some rules that allow the automaton to process the symbols according to these rules to eventually deliver an output, such as Acceptance or Rejection of the sequence as belonging or not to the language recognized by the automaton. The pattern of symbols in the sequence is characteristic of the language to which the sequence belongs. We can interpret this process as a metaphor for a chemical reaction or combination of chemical reactions, as one can think of chemical reactions as the result of molecular recognition events that occur precisely, predictably, and repeatably.
Then, we can ask if the power and complexity of biochemistry are necessary to carry out computations using only chemistry. To do so it is useful to recall that languages are classified into an inclusive hierarchy, the Chomsky hierarchy (Rich, 2008, Hopcroft et al., 2007, Chomsky, 1956, Sudkamp, 2006) (cf. Table 1), and that there is a direct correspondence between language complexity and the capabilities of the automata that recognize the language. The most powerful automata are the Turing machines (Turing, 1936).Table 1. The Chomsky HierarchyGrammarsLanguagesAccepting AutomataType 0 grammars, phase-structure grammars, unrestricted grammarsRecursively enumerableTuring machine, Non-deterministicTuring machineType 1 grammars, context-sensitive grammarsContext-sensitiveLinear-bounded automata (Bounded tape-length Turing machine)Type 2 grammars, context-free grammarsContext-freeOne-Stack Pushdown AutomataType 3 grammars, regular grammars, left-linear grammars, right-linear grammarsRegularDeterministic FiniteAutomata, Non-deterministic FiniteAutomataLanguages are generated by grammars. By gradually imposing restrictions on them (Hopcroft et al., 2007), grammars are categorized into an inclusive four-level hierarchy, the Chomsky hierarchy. Type-0 are unrestricted grammars and Type-3 the most restricted. Type-1 grammars correspond to Type-1 Languages, which are also called Context Sensitive Languages (CSL). Type-2 and Type-3 correspond to Context Free (CFL) and Regular (RL) languages, respectively. Each class of languages in the Chomsky hierarchy has been characterized as the languages generated by a family of grammars and accepted by a type of machine. The relationships developed between generation and recognition are summarized in this table, which is adapted from p. 338 of Sudkamp (2006). Type 0 and Type 1 grammars are accepted by Turing machines, hence the horizontal line in the Table that separates them from Types 2 and 3.
We answer the aforementioned question by providing non-biochemical realizations of the automata using non-biochemical reactions running in a “one-pot reactor,” that is, in a single well-mixed container where multiple rounds of reactions can take place. We do not need any intermediation from either external geometrical aids to channel and direct the chemical fluids or from reactions involving complex biomolecules. To carry out computations we rely fully on the power of molecular recognition associated with the occurrence of chemical reactions and the robustness provided by an Avogadro′s number of “processors” working simultaneously. For this, we will introduce in our experimental examples the means for the chemical rendering (translation) of alphabet symbols, the chemical copy of the sequence (transcription), a means to feed the sequence (i.e., input the individual symbols), a means to sequentially read the output of the processed sequence, and an autonomous physicochemical indicator to identify the patterns corresponding to sequences in the language recognized by the automaton. After the symbols are fed to the reactor, all the processing and energy used are exclusively chemical. Our purpose is to explore and show how chemical reactions, without using bio-chemistry, reaction-diffusion constructs, or any external auxiliary guidance, do chemical sequence identification in a way equivalent to automata in abstract computations. (We will call this “native chemical computation.”) We will not attempt to establish any theory of the correspondence between reaction complexity and automata.
Chemical computing has an interesting and very rich history, making it impossible to offer here a proper review (for more detailed material cf., e.g., Katz, 2012). We will only highlight a few of its many key developments as they relate to the work we present here. In the early 1970s, Conrad (1972) studied how information processing in molecular systems differs from electronic digital computing. The concept of a theoretical chemical diode first suggested by Okamoto et al. (1987) was further developed theoretically by Hjelmfelt et al. (1991) to suggest that neural networks and chemical automata could be constructed connecting several chemical diodes. The Turing completeness of chemical kinetics was theoretically studied by Magnasco (1997). The first experimental realization of chemical AND and OR logic gates using reaction-diffusion was achieved by Tóth and Showalter (1995), followed by XOR gates (Adamatzky and Costello, 2002) and counters (Gorecki et al., 2003). Chemical logic gates are indeed still an active area of research (Gentili et al., 2012, Wang et al., 2016) owing to the difficulties associated with linking many gates to carry out more advanced or meaningful computations such as the ones required to Accept/Reject languages in the Chomsky hierarchy (cf. Table 1). Native strictly chemistry-based computation can be argued (Katz, 2012) to occur in life and has been demonstrated in practice using DNA (Adleman, 1994, Benenson, 2009) or the properties of chromatin (Prohaska et al., 2010, Bryant, 2012). The computational power of DNA has also been studied theoretically (Soloveichik et al., 2010). In summary, most artificial approaches to chemical computing, inspired by living systems, focus on reaction-diffusion systems mostly representing logic gates or use complex biomolecules to solve very specific problems. Finally, an example of a purely chemical, one-pot, non-reaction-diffusion Turing Machine (Turing, 1936) implemented using the Belousov-Zhabotinsky chemical reaction is contained in Pérez-Mercader et al. (2017).
In what follows we demonstrate native “one-pot-reactor” experimental realizations of computations for the recognition of well-known languages at different levels in the Chomsky hierarchy and provide a comparison of the corresponding chemical and abstract automata. We also present a suitable physico-chemical metric to characterize the result of the automaton′s computation.
