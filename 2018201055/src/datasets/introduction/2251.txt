An important step in the development of a mathematical model for a biological system is using experimental data to identify model parameters. In a conventional approach, the experimental data of most utility are quantitative time courses and/or dose-response curves. Parameters are adjusted to minimize the difference between the model outputs and the experimental data (as measured, for example, by a residual sum-of-squares function).
In some cases, there are straightforward solutions for parameter identification. For example, software tools such as Data2Dynamics (Raue et al., 2015) and COPASI (Hoops et al., 2006) implement practical parameterization methods for biological applications. These programs can, for example, use gradient-based optimization to solve the benchmark problems of Raue et al. (2013) and Hass et al. (2019). These problems feature ODE models, which typically consist of tens of equations. One contains 500 equations. As powerful and practical as Data2Dynamics and COPASI are, not all biological models fall into a category that can be solved with these tools. When current software tools are inadequate, modelers must resort to either problem-specific code or manual adjustment of parameters. Both these approaches are tedious from the perspective of the modeler and also present challenges for reproducibility of the modeling work (Medley et al., 2016, Waltemath and Wolkenhauer, 2016). Therefore, there is strong motivation to expand the scope of problems that can be solved using general-purpose software compatible with standard model definition formats.
We developed the software PyBioNetFit to solve three major classes of parameterization problems for which current software solutions are limited. (1) Problems with larger than usual numbers of ODEs. The size of an ODE-fitting problem depends primarily on two considerations: the number of differential equations and the number of free parameters. Parameterization cost typically has a dependence on both these quantities, but the relative importance depends on the method used for parameterization. Large problem size in terms of equation count often arises when using rule-based modeling. Rule-based modeling is the preferred approach for processes in which a combinatorial explosion in the number of possible chemical species makes it challenging to enumerate every possible chemical reaction (Chylek et al., 2013, Faeder et al., 2005). In a rule-based model, a concise set of rules can be expanded to generate a much larger system of ODEs (hundreds to thousands of equations from a model with tens of rules). Although the number of equations grows large, the number of parameters remains proportional to the number of rules, which is typically much smaller than the number of rule-implied reactions. In this way, rule-derived ODE models differ from manually formulated ODE models, which typically have a parameter count proportional to the number of reactions. For ODE systems at the scale typically found in rule-based modeling, gradient-based methods using finite differences or forward sensitivity analysis are computationally expensive. Adjoint sensitivity analysis enables more scalable gradient computation (Cao et al., 2002), but current software is limited in the supported workflows. (2) Problems featuring models that are simulated stochastically. This class of problems includes rule-based models in which the implied ODE system is so large that it cannot be derived from rules or numerically integrated efficiently (Sneddon et al., 2011, Suderman et al., 2019). In such cases, the objective function is not differentiable, so standard gradient-based methods cannot be used. (3) Problems including unconventional experimental data, in particular non-numerical qualitative data. Such datasets are often collected by experimentalists and have the potential to inform model parameterization (Mitra et al., 2018), but currently are rarely used in practice. Notable exceptions are works of Tyson and coworkers (Chen et al., 2000, Chen et al., 2004, Csikász-Nagy et al., 2006, Kraikivski et al., 2015, Oguz et al., 2013) and Pargett and coworkers (Pargett and Umulis, 2013, Pargett et al., 2014).
We address problems (1) and (2) by using parallelized metaheuristic optimization algorithms in place of gradient-based algorithms. Metaheuristics are a well-established class of optimization algorithms that do not rely on gradient information. If gradient information is available, metaheuristics can benefit by working in combination with gradient-based methods (Villaverde et al., 2019), as in memetic algorithms (Neri et al., 2012). Metaheuristics carry no guarantee for convergence to a global optimum but are found to be effective in many use cases (Gandomi et al., 2013). Examples of metaheuristics include differential evolution (Storn and Price, 1997), particle swarm optimization (Eberhart and Kennedy, 1995), and scatter search (Glover et al., 2000). Such algorithms often include some type of iterative randomized selection of candidate parameter sets, followed by evaluation of the selected parameter sets, which is used to direct the selection of parameters in future iterations to more favorable regions of parameter space. Many modern descriptions of metaheuristics allow for parallelized evaluation of parameter sets (Moraes et al., 2015, Penas et al., 2015, Penas et al., 2017), which is valuable when each model simulation is computationally expensive. Although these algorithms are well-established, software designed for biological applications is limited. COPASI (Hoops et al., 2006) and Data2Dynamics (Raue et al., 2015) both include metaheuristic algorithms, but these algorithms are not parallelized, which limits their performance with computationally intensive models. The software BioNetFit (Thomas et al., 2016) (called BioNetFit 1 in this report to distinguish it from the newly developed software) was an early effort to use a parallelized evolutionary algorithm to parameterize rule-based biological models. However, the BioNetFit 1 algorithm is inefficient in many cases, and in general, optimization algorithm performance is problem dependent, and so a toolbox of methods is needed to enable a wide range of problems to be solved efficiently. PyBioNetFit was inspired by BioNetFit 1 but is an entirely new code base that includes multiple, robust metaheuristic algorithms.
We address Problem 3 by following the approach of Mitra et al. (2018) for parameterizing models using both qualitative and quantitative data. In this approach, properties of interest are represented as one or more inequality constraints on the outputs of a model, enforced during some portion of a simulation. In some cases, a single qualitative observation, such as the viability of a particular mutant, implies several system properties (inequalities). For example, in a model of the yeast cell cycle (Laomettachit et al., 2016), if a yeast strain is viable, three variables representing bud formation, origin activation, and spindle assembly must each exceed a specified threshold. After defining inequalities, we cast each inequality as a static penalty function (Smith and Coit, 1997), added to the objective function to be minimized. The result is a scalar-valued objective function with contributions from both qualitative and quantitative data; this function is minimized during fitting. This approach is fairly straightforward, and it has been demonstrated to be effective for parameterization of biological models using qualitative data (Mitra et al., 2018). An important feature (in contrast to other constrained optimization methods) is allowance for the possibility that some of the inequality constraints may not be satisfied (because they arise from uncertain experimental data).
To extend this approach for use in general-purpose software, we require a language to express arbitrary system properties of interest. In systems biology, there is no established means for formalizing system properties, although attempts have been made to do so with temporal logic (Clarke et al., 2008, David et al., 2012, Heath et al., 2008, Kwiatkowska et al., 2008), sometimes as part of model parameterization (Hussain et al., 2015, Khalid and Jha, 2018, Liu and Faeder, 2016). There is a lack of software tools tailored for biological modeling that support property specification languages—most studies that incorporate temporal logic do so with problem-specific code. In addition, there are few demonstrations of how the formalism of temporal logic, originally developed for computer science applications (Clarke et al., 1986), can be applied to describe biologically interesting properties such as case-control comparisons. To address these deficiencies, we developed the Biological Property Specification Language (BPSL) as part of PyBioNetFit. BPSL is a domain-specific language for declaration of biological system properties and allows such properties to be used as part of parameterization.
To complement its parameterization features, PyBioNetFit includes methods for uncertainty quantification of parameter estimates. Bayesian uncertainty quantification can be performed using Markov chain Monte Carlo (MCMC) with the Metropolis-Hastings (MH) algorithm (reviewed by Chib and Greenberg, 1995) or parallel tempering (reviewed by Earl and Deem, 2005). These methods start with an assumed prior probability distribution for each parameter, and a likelihood function, and aim to sample the multidimensional posterior probability distribution of the parameters given the data. Simulations can be performed using sampled parameter sets to quantify the uncertainty of model predictions. PyBioNetFit also supports bootstrapping, which performs uncertainty quantification by resampling data (Efron and Tibshirani, 1993, Press et al., 2007).
Although PyBioNetFit and BPSL were designed primarily for model parameterization, BPSL also enables formalized approaches to model checking, somewhat as in computer science (Clarke et al., 1999), and design, somewhat as in optimal control. For our application, we define model checking as performing verification of whether a model reproduces a set of specified properties. Applications of formal model checking to biological processes have been considered in earlier work, including for stochastic models (Clarke et al., 2008, Heath et al., 2008, Kwiatkowska et al., 2008). Much more often, model checking in biology is done informally as part of building a model. However, as models become more detailed, with an increasing number of known properties, a more formal and systematic system of model checking is useful: it can help in communicating what knowledge went into building the model and for comparing the predictions of different models. Design represents a related application, analogous to the classical use of constrained optimization techniques. In a design problem in PyBioNetFit, we seek an intervention (a perturbation of a parameterized model) that brings about a desired set of BPSL-defined system behaviors, for example, choosing drug doses to up- or down-regulate the activity of a target pathway.
All the above-mentioned features of PyBioNetFit are designed to be used in conjunction with existing model definition standards, avoiding the need for problem-specific code. PyBioNetFit natively supports models defined in BioNetGen Language (BNGL) (Faeder et al., 2009), a language for rule-based models, and core SBML (Hucka et al., 2003), a language for more conventional models. For BNGL models, PyBioNetFit supports the simulators available in BioNetGen (Harris et al., 2016, Faeder et al., 2009, Blinov et al., 2004, Sneddon et al., 2011). For SBML models, PyBioNetFit uses the simulator libRoadRunner (Somogyi et al., 2015). PyBioNetFit has a modular design that makes it possible to add support for additional model standards and simulators in the future. Currently, other model standards are indirectly supported by converting to BNGL or SBML. For example, rule-based models defined in the Kappa language (Danos and Laneve, 2004, Sorokina et al., 2013) can be converted to BNGL using the software tool TRuML (Suderman and Hlavacek, 2017).
To demonstrate the capabilities of PyBioNetFit, we solved a series of example optimization problems. We solved a total of 31 problems, 25 of which featured published, biologically relevant models (Blinov et al., 2006, Boehm et al., 2014, Brännmark et al., 2010, Chylek et al., 2014, Dunster et al., 2014, Erickson et al., 2019, Faeder et al., 2003, Fey et al., 2015, Harmon et al., 2017, Hlavacek et al., 2018, Kocieniewski et al., 2012, Kozer et al., 2013, Kühn and Hillmann, 2016, Lee et al., 2003, Mitra et al., 2018, Monine et al., 2010, Mukhopadhyay et al., 2013, Oguz et al., 2013, Romano et al., 2014, Shirin et al., 2019, Suderman and Deeds, 2013, Webb et al., 2011, Zheng et al., 2012). With four of these problems, we performed extensive benchmarking using different algorithms and different levels of parallelization. Not surprisingly, we find that the optimal algorithm depends on the fitting problem, which demonstrates the value of having a toolbox of several algorithms available. We then focus on a particularly challenging example problem: parameterizing the model of Tyson and co-workers for cell cycle control in yeast (Chen et al., 2000, Chen et al., 2004, Csikász-Nagy et al., 2006, Kraikivski et al., 2015, Oguz et al., 2013). This model was originally parameterized by hand-tuning (Chen et al., 2000, Chen et al., 2004) and later by automated optimization with problem-specific code (Mitra et al., 2018, Oguz et al., 2013). Here we consider our most recent description of the problem (Mitra et al., 2018), which has a 153-dimensional parameter space. We define the problem using BPSL and solve it using the general-purpose functionality of PyBioNetFit. Thus we demonstrate that PyBioNetFit can solve this general class of problem, that of using both qualitative and quantitative data to parameterize a biological model.
Finally, we considered a model describing drug intervention in autophagy signaling (Shirin et al., 2019) to demonstrate the capabilities of PyBioNetFit and BPSL beyond model parameterization. We show that BPSL can be used to define a set of system properties, which can then be used in model checking. We also demonstrate how BPSL can be used to configure a design problem, finding a combination of drug doses to achieve a desired level of autophagy regulation.
