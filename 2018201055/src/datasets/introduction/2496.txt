In this article, we study the parallel machine scheduling problem on unrelated machines with sequence- and machine-dependent setup times, machine eligibility restrictions, and the total weighted completion time as objective function. This problem is well-known in the scheduling literature and classified as R/sijk, Mj/∑wjCj (Pinedo, 2012) in the established α/β/γ-notation (Graham et al., 1979). For convenience, we refer to this problem as UPMSP (Unrelated Parallel Machine Scheduling Problem) in the remainder of this article. UPMSP is NP-hard in the strong sense since the more specific problem P//∑wjCj of minimizing the total weighted completion time on identical machines is NP-hard in the strong sense (Skutella and Woeginger, 2000).
The problem can be described as follows: a set of jobs has to be processed on a set of machines, where (i) each job has to be processed exactly once, (ii) the processing of a job must not be interrupted (non-preemption), and (iii) a machine may be capable of processing a job or not (machine eligibility restrictions). Processing times depend on the job and the processing machine, while sequence-dependent setup times depend on the job, the preceding job, and the processing machine. Furthermore, each job has a priority level (weight). The goal of UPMSP is to find a feasible set of machine schedules with minimal total weighted completion time.
There are several real-life settings where decision makers face UPMSP. In disaster response, rescue units (machines) are scheduled to process emergency incidents (jobs) with different priorities (weights). Setups are required by rescue units for traveling between incidents’ locations (Wex et al., 2014). Another application are traffic flow networks where repairmen (machines) have to repair broken toll plazas or toll bridges (jobs) with different traffic throughput rates (weights). Setups are represented by travel times of repairmen between toll plazas or bridges (Weng et al., 2001). UPMSP is also found in injection molding departments where machines are used to produce different components (jobs) with certain importance (weights) and for which setup times are required for dies or molds (Chen, 2015).
Solving medium- or large-scale instances of UPMSP—and even of the more specific problem where no machine eligibility restrictions apply and where setup times are not machine-dependent—to optimality is computationally challenging as recent studies show (Arnaout, Rabadi, 2005, Chen, 2015, Rauchecker, Schryen, 2015, Schryen, Rauchecker, Comes, 2015, Tsai, Tseng, 2007, Weng, Lu, Ren, 2001, Wex, Schryen, Feuerriegel, Neumann, 2014). In order to overcome efficiency limitations due to sequentially executed algorithms, researchers can rely on recent technological developments in high performance computing (HPC), which refers to the use of parallel computing architectures. HPC is particularly relevant since speed improvement on a single core is limited because of technological reasons (Hager and Wellein, 2010, p. 23). Modern PCs and even smartphones have multiple cores, which allow for parallel code execution. At the extreme, computer clusters and supercomputers—containing up to several millions of cores—are pushing the boundaries of HPC (TOP500, 2017). HPC has been successfully applied to a broad range of problems in many scientific disciplines, including biology, chemistry, physics, geology, weather forecasting, aerodynamic research, and computer science (Bell, Gray, 2002, Vecchiola, Pandey, Buyya, 2009)—but there is little research on using HPC for scheduling problems. Nowadays, taking advantage of HPC does not require having access to a supercomputer; it can also be done on computing clusters, which have become commodity IT resources. For example, they are available at many universities and are provided by some cloud providers, for example, as part of the Amazon Web Services (Mauch et al., 2013). To sum up, HPC has not only become technologically feasible but also economically affordable (Hager and Wellein, 2010, p. 1).
However, in order to exploit the capabilities of HPC, algorithms have to be parallelized. In this work, we adapt a serial branch-and-price algorithm, which was suggested by Lopes and de Carvalho (2007), to solve UPMSP. Their algorithm was designed for the parallel machine scheduling problem on unrelated machines with sequence-dependent setup times, machine availability dates, release dates, due dates, and the total weighted tardiness as objective function. We suggest an algorithmic parallelization of the adapted b&p algorithm and conduct extensive computational experiments on an HPC cluster to analyze the scalability of our parallel approach on a large number of cores.
1.1. Literature reviewScheduling problems appear in many forms and have attracted thousands of research papers. In order to structure this large body of research, comprehensive literature reviews (e.g., Allahverdi, 2015, Allahverdi, Gupta, Aldowaisan, 1999, Allahverdi, Ng, Cheng, Kovalyov, 2008, Cheng, Sin, 1990) and books (e.g., Brucker, 2007, Pinedo, 2012, Rabadi, 2016) have been published. We can divide scheduling problems into problems which account for setup times and those which do not. Allahverdi, Gupta, Aldowaisan, 1999, Allahverdi, Ng, Cheng, Kovalyov, 2008 and Allahverdi (2015) provide comprehensive surveys about all scheduling problems accounting for setup times. They further divide these into problems with sequence-independent setup times and problems with sequence-dependent setup times. In our overview, we focus on problems that can be represented as R/STSD/γ, i.e., scheduling on unrelated parallel machines with sequence-dependent setup times. We further restrict γ to objective functions that are at least as general as the total weighted completion time.According to Allahverdi, Gupta, Aldowaisan, 1999, Allahverdi, Ng, Cheng, Kovalyov, 2008 and Allahverdi (2015), the first research focusing on this type of problems was conducted by Zhu and Heady (2000), who considered due dates and the total weighted earliness/tardiness (∑wj′Ej+∑wj″Tj) objective function, which is equivalent to the total weighted completion time when all earliness weights and due dates are 0. They modeled R/STSD/∑wj′Ej+∑wj″Tj by a mixed-integer program (MIP) and were capable of finding optimal solutions for up to 9 jobs and 3 machines. Akyol and Bayhan (2008) present an exact Artificial Neural Network algorithm but they were not able to solve larger instance sizes. A Tabu Search was presented by Bozorgirad and Logendran (2012) while Zeidi and Mohammad Hosseini (2015) have chosen a hybrid Genetic Algorithm/Simulated Annealing approach.In the absence of earliness weights, ∑wj′Ej+∑wj″Tj turns into the total weighted tardiness objective function (∑wjTj), which is equivalent to the total weighted completion time when all due dates are 0. Tavakkoli-Moghaddam and Aramon-Bajestani (2009), Lopes and de Carvalho (2007), and Lopes et al. (2014) present branch-and-bound (b&b) and branch-and-price (b&p) algorithms based on MIP formulations for R/STSD/∑wjTj, with the b&b algorithm being capable of solving instances with up to 10 jobs and 4 machines and the b&p algorithms being capable of solving instances with up to 180 jobs and 50 machines. The total weighted tardiness objective was further tackled with Genetic Algorithms (Joo and Kim, 2012), Tabu Search (Logendran et al., 2007), Simulated Annealing (Kim et al., 2003), and several other heuristic approaches (Alvelos, Lopes, Lopes, 2016, de Paula, Mateus, Ravetti, 2010, Lin, Hsieh, 2014, Rauchecker, Schryen, 2015, Zhang, Zheng, Weng, 2007). Our problem R/STSD/∑wjCj has been formulated as a quadratic binary program and tested with the off-the-shelf solver Gurobi by Wex et al. (2014) and Schryen et al. (2015). Their computational studies indicate that this formulation and strategy is not efficient as it fails to compute optimal solutions for small-sized instances consisting of 40 jobs and 10 machines within several hours. Other approaches approximate this problem with Genetic Algorithms (Tsai and Tseng, 2007), b&p based heuristics (Rauchecker and Schryen, 2015), and several problem-specific heuristics (Arnaout, Rabadi, 2005, Chen, 2015, Weng, Lu, Ren, 2001).The common problem of (meta-) heuristic approaches is the fact that they usually cannot guarantee optimality. Consequently, efficient exact algorithms are not only desirable for solving large real-world problems to optimality, but also they are an important tool for benchmarking (meta-) heuristics. However, our literature review shows that (i) in contrast to heuristics, only very few research on exact algorithms for UPMSP and related problems exists and (ii) none of the suggested exact algorithms has been parallelized in order to leverage the potential of modern HPC capabilities. However, the most promising of the presented exact approaches use b&b and especially b&p algorithms, which offer a high potential for parallelization (e.g., Eckstein, 1994, Migdalas, Pardalos, Storøy, 2013; or Ralphs et al., 2003). B&p algorithms were conceptualized by Barnhart et al. (1998) and use both a b&b algorithm and a column generation procedure (Dantzig, Wolfe, 1960, Desaulniers, Desrosiers, Solomon, 2006, Lübbecke, Desrosiers, 2005) to solve integer programs with many variables. This kind of algorithm has widely been used for tackling scheduling problems, including studies by Bard and Rojanasoonthon (2006), Fei et al. (2008), van den Akker et al. (1999), and Chen, Powell, 1999, Chen, Powell, 2003. However, only a few studies use parallel implementations of b&b or b&p algorithms to tackle scheduling problems, see, for instance, Perregaard and Clausen (1998), Clausen and Perregaard (1999), Crespo Abril and Maroto Alvarez (2005), Aitzai and Boudhar (2013), and Chakroun et al. (2013). Just recently, a new parallel b&p-based heuristic for UPMSP has been suggested (Rauchecker and Schryen, 2015). We contribute to closing the aforementioned research gap by suggesting and computationally validating an exact parallel b&p algorithm for UPMSP as outlined in Section 1.2.
1.2. Contribution and structureIn Section 2, we present the mathematical formulation of our scheduling problem. In Section 3, we propose an adaptation of the serial b&p algorithm suggested by Lopes and de Carvalho (2007) to UPMSP. Section 4 presents a parallelized version of the adapted b&p algorithm. To the best knowledge of the authors, this is the first time that an exact b&p algorithm for a scheduling problem has been parallelized. In Section 5, we demonstrate the applicability of the parallelized algorithm on a Linux-based HPC cluster with extensive numerical experiments and measure its performance using established scalability metrics. With our experiments, we show that our parallelization approach achieves high efficiencies with even superlinear speedups for some instances. We further show that the wall time of our tested instances is reduced from up to 94 h for the most difficult test instance in serial execution to less than 6 min when the algorithm is executed on 960 processes. We discuss those finding in Section 6 before we finally conclude in Section 7.
