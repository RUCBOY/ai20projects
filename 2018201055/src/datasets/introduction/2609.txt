The model of computation known as spiking neural P systems, or SN P systems, was introduced in [11] and is one of many models in membrane computing. Membrane computing deals with models inspired by the functions, structures, and operations from living cells [22]. SN P systems are parallel and nondeterministic models inspired by the spiking of neural cells or neurons. Many ideas from living neurons and mathematics have inspired investigations on SN P systems: they are Turing universal or computationally powerful, i.e., able to solve any Turing computable problem as in the seminal paper [11], in succeeding papers as in [10], [26], [41] and variants as in [3], [27], [28], [29], [30], [37], [39], [40]; they are computationally efficient, able to solve hard problems in feasible time as in [14], [15], [16], [19], [20], [33] and can solve some real-world problems, as in [31], [35], [36].
To aid in further investigation, design, and analysis of SN P systems, computer simulators on sequential and parallel machines have been introduced, as in the PLingua programming environment in [17] and the parallel implementations in [2], [6], [18]. In order to efficiently represent and simulate SN P systems and variants, their matrix representations have been introduced and used in [5], [6], [12], [38]. The use of a matrix representation can allow a more efficient simulation since some linear algebra operations can be performed independently and thus in parallel.
Solutions using SN P systems and other P system models to solve problems can either be of a uniform or nonuniform type: the first type means that the solution is dependent only on the problem size, while the second type is dependent not only on the problem size but also on each specific instance of the problem. An active direction for investigation is how to efficiently design representations and simulation algorithms for both solution types in sequential or parallel hardware, see e.g., [2], [5], [6], [18].
In SN P systems as in living neurons, the information is encoded in only one type of signal, the spike. In SN P systems, the processor is the neuron which contains rules to process the spikes. Spikes are communicated from one neuron to another using synapses or edges that link neurons together. In the case of SN P systems, synapses are only communication links without any effect in the spike processing. A variant of SN P systems known as SN P systems with rules on synapses, or RSSN P systems, takes ideas from neuroscience: it is known that synapses are not only communication links since they also perform processing of spikes [28]. In RSSN P systems, the neurons are only collectors of spikes, and the rules are placed instead on the synapses.
While syntax is similar to SN P systems, semantics of RSSN P systems can be “richer”, thus requiring fewer resources such as neurons, rules, and synapses. For example, using the same forms of rules, i.e. standard or extended, a (Turing) universal SN P system for computing functions using 67 (with standard rules) and 41 neurons (with extended rules) are given in [41] while RSSN P systems with only 39 and 30 neurons, respectively, are required [28].
Many works on RSSN P systems have focused on their computational power, i.e., how to achieve Turing universality, as in [28], [30], the inclusion of synapse weights [42], and considering other semantics in [24], [25], [32], [34] to name a few. At present there are no works on RSSN P systems and their complexity classes for solving hard, i.e., NP-complete, problems.
The organization and contributions of this work are as follows, presenting several novel results. In particular, after recalling the RSSN P system definition (Section 2) this work is the first to define complexity classes for problems solved by RSSN P systems (Section 3). In any model of computation, traditional or otherwise, it is always important to define complexity classes of problems that are solved by the models, e.g., [9], [19], [21], [23], [33]. This work is also the first to define uniform and nonuniform solutions to the hard problem Subset sum using RSSN P systems (Section 4). We show how our solutions improve on solutions using SN P systems, e.g., a linear decrease in the number of rules, neurons, or synapses, while reducing the forms of rules used.
We also introduce for the first time a matrix representation and simulation algorithm for RSSN P systems to aid in their investigations (Section 5). The time and space requirements of our representation and algorithm follow. Afterwards, we create sequential and parallel simulators using our matrix representation and algorithm (Section 6). We perform “small” computer experiments which demonstrate that our implementation and data at present make uniform and nonuniform solutions better suited for sequential and parallel machines, respectively. Lastly, final remarks and directions for future work are in Section 7.
