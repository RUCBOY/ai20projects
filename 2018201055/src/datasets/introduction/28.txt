Being able to state properties about graphs and to reason about them is important in many areas of computer science where graphs play a relevant role. For instance, in software and system modelling, where models are described using different graphical notations, graph properties may be used to describe properties of the given models, and reasoning tools may be used for model validation. Similarly, in the context of graph databases, graph properties can be used to express integrity constraints or just to express queries to the database. In that context, reasoning tools may allow us to check these constraints or to verify and test the search engine to evaluate these queries.
Two kinds of approaches can be used to describe graph properties. The first one is based on using some standard logic, after encoding some graph concepts into it. For instance, Courcelle (e.g., [1]) studied a graph logic defined in terms of first-order (or monadic second-order) logic, extended with a predicate node(n) for stating that n is a node, and with a predicate edge(n,n′), for stating that there is an edge from node n to n′. A similar logic, but with some important differences is presented in [2] by Cardelli, Gardner and Ghelli whose expressive power is shown to be between first-order and monadic second-order logic. The second kind of approach is based on defining a dedicated logic, where graph properties may be expressed in terms of formulas that directly include graphs or graph concepts. The most important example in this direction is the Logic of Nested Graph Conditions (LNGC), introduced by Habel and Pennemann [3], which was proven to be equivalent to the first-order logic of graphs of Courcelle.
There are two main advantages in working with a logic like LNGC. The first one is efficiency. Pennemann [4] showed that a specialized prover for their logic outperformed some standard provers, like Darwin [5] or Vampire [6], when applied to graph formulas using Courcelle's logic. The second advantage is generality, in the sense that LNGC, being formulated in terms of category theory, can be used for any category of structures, as long as that category satisfies some general properties, i.e., LNGC can be used for stating properties and reasoning about many classes of graphs. This is important because there are many kinds of graphical structures that can be of interest in different areas of Computer Science. Conversely, using a standard logic, we need a different encoding for each class of structures. Moreover, specific results for one class may not be easy to transfer to another.
A main problem of LNGC is that it cannot be used to express navigational properties, i.e., path properties like “there is a path from node n to n′”, which are important in many application areas, but are (monadic) second-order properties. In this sense, the main aim of this paper is the presentation of an extension of LNGC that allows us to state path properties and to reason about them.
This paper puts together, extends and complements previous work from the authors on graph logics, most of it on LNGC (i.e., without path properties) or some fragments of it. In particular, in [7] we presented the first version of our tableau method for reasoning in LNGC, showing its soundness and completeness, while in [8], [9] we presented a method for generating models of LNGC formulas. It is worth pointing out that our results show that our tool AutoGraph [9] can compete with respect to efficiency with a general tool like Alloy, thereby computing stronger results in the sense that AutoGraph generates minimally representable symbolic models (without a predefined scope as in Alloy). In [10] we dealt with paths for the first time, but in a very restrictive setting: we considered only Horn clause-like formulas over XML structures, i.e., trees. The problem was considerably simpler than the one approached in the current paper. First, because trees are simpler than graphs and, second, because we worked only with a fragment of LNGC. Finally, [11], [12] can be considered extensions of this paper, even if they have been published before. In particular, in [11] we described some preliminary ideas of how our approach could be generalized to arbitrary categories of structures, and in [12] we showed that this new logic is an institution [13], providing means for structuring and modularizing specifications over it [14]. In both cases, the work was essentially semantical, working at the model level rather than at the deduction level.
The main contributions of this work are:
•The definition of GNL (Graph Navigational Logic), extending LNGC with path expressions, but using a notion of satisfaction (a-satisfaction), which is not the standard one (m-satisfaction). Using a-satisfaction considerably simplifies some technical constructions and, most importantly, allows us to avoid exponential branching in our tableau proofs, which we would have if using m-satisfaction.•The definition of a tableau method for reasoning in this logic, showing its soundness and completeness. The method uses nested tableaux, as in [7], with new tableau rules that are needed because of path expressions.•As a by-product, we have that our new tableau method is also a sound and complete proof method for LNGC (with respect to a-satisfaction). In this sense, it must be said that the tableaux rules presented in this paper are not a straightforward extension of the ones in [7], because of the use of a-satisfaction.
The paper is organized as follows. In Sect. 2 we introduce graphs, patterns and how they are related, and in Sect. 3 we introduce the syntax and semantics of GNL, including some basic results that are needed in the rest of the paper. In Sect. 4 we present our tableau reasoning method, and in Sect. 5 we show that the method is sound and we present our completeness results. In particular, we show that our method is complete for a class of graphs including infinite paths. In addition, we show that our tableau rules, excluding path unfolding, are complete for the class of graphs when formulas do not include path expressions. This can be seen as a reformulation of the results presented in [7], where only monomorphisms were used in formulas and in the satisfaction relation. In that new reformulation two additional tableau rules are needed but, conversely, the completeness proof is simpler, because of the notion of satisfaction used. In Sect. 6 we describe related work and in Sect. 7 we present some conclusions and we discuss how GNL could be used in the areas of Model Driven Development and as a logical foundation for graph databases. To enhance readability, the proofs of some technical intermediate results are just sketched, but in Appendix A we include all the missing details. To conclude, Appendix B shows a slightly more complex example than the examples used in the main text of our tableau reasoning method.
