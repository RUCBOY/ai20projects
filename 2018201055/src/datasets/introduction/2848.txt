Users interact with the file system by navigating, creating, moving, renaming, copying or deleting files, or directories. Digital forensic investigators normally use digital forensic tools to investigate criminal cases (Garfinkel, 2010; Gl and Kugu, 2017). When digital forensic tools parse the NTFS file system they often show only selected parts of each MFT record. In order to validate the results of the tools it would be necessary for digital forensic investigators to use hex viewers, or tools such as mftrcrd (Schicht, 2018) to manually interpret the MFT records. In NTFS, metadata about files is mainly found in the system file $MFT (master file table) [2, p.353], but metadata might exist in other system files including $ObjId, $LogFile, $UsnJrnl, $Secure, etc. Typically, file metadata could include timestamps, file names, block allocations (data runs or extents), Object IDs, different indexes, etc [2, chap. 13].
This paper will focus on Object Identifers (OIDs). The Object ID index found in the $ObjId system file can help the investigator to find all allocated files that have an Object ID, which will assist in event reconstruction of user activity. OIDs are created based on typical user activity and are used by Windows in order to track an object (file, directory or link) even if the object changes location or name (Microsoft, 2016). OIDs will be created when a file is opened by the user in Windows File Explorer, or when the file is opened or saved by some applications (Parsonage, 2008). A user can also use the command line tool fsutil objectid to create, delete or set OIDs. If a user moves a file to another volume the Object ID might change, however, the Birth Object ID and the Birth Volume Object ID should be preserved (Microsoft, 2016). A volume is a collection of addressable sectors that can be used for storage, and a volume can also be a partition [2, p.70]. In the context of this paper, the volume is a partition using the NTFS file system. According to Microsoft the Windows OS uses OIDs in order to track files (Microsoft, 2016).
A digital forensic tool might show OIDs connected to a file, but different digital forensic tools deviate in how OIDs connected to a file are presented. We performed an experiment to determine if forensic tools display OIDs. Thus we tried X-Ways Forensics and Autopsy on a file which was known to have connected OIDs. The results were that X-Ways Forensics showed only the Object ID key, and Autopsy (Sleuthkit) failed to show any information relating to OIDs. EnCase shows Object IDs and parses the Object ID timestamp, sequence number and the MAC address (Habben, 2018). If a file, directory or link is assigned OIDs, the following will be assigned:
•Object ID (used as a key in the index)•Birth Volume Object ID (special identifier equal to the Object ID of the $Volume system file from the volume the OIDs were created)•Birth Object ID (equal to the first Object ID assigned and should not change)•Domain Object ID (always zeros, reserved)
It is not enough to just display an artifact, the investigators need to understand what it means. The authors consider OIDs to be important for digital forensics for the following reasons:
•OIDs will show which boot session a file with OIDs belongs too (Leachi et al., 2005), which can assist in timeline creation.•OIDs can show the node (MAC-address) used by the computer that created the OIDs (Leachi et al., 2005). This means we will be able to determine to which computers the external storage medium has been attached, as long as the user has accessed files and created new OIDs.•OIDs can show in which sequence files have been assigned OIDs within a boot session. This might assist in detecting manipulation of timestamps and in building timelines.•The $ObjId index can be used as a triage tool in order to identify files or directories the user has accessed.•The Birth Volume Object ID might be used to identify the file system volume used when the file was first assigned OIDs.
The Object ID is a unique 16 byte identifier used to identify files on a NTFS volume (Microsoft, 2016). Any file that obtains an Object ID, will also have a Birth Volume Object ID, a Birth Object ID and a Domain ID (Microsoft, 2016). The Birth Volume Object ID (16 bytes) is used for identifying the volume the file was located on when it first obtained an OID (Microsoft, 2016). The Birth Object ID (16 bytes) is the first Object ID assigned to the file. The Object ID may change if the file is moved, but the Birth Object ID should remain constant (Microsoft, 2016). The Domain ID is a 16 byte structure reserved for identifying a domain, and must be 16 bytes of zeros (Microsoft, 2016). Our experiments attempt to observe and assess if the description of fsutil by Microsoft is still true in Windows 10.
OIDs are 16 bytes in size and contain a 60 bit timestamp, which is the number of 100 ns intervals since 15th of October 1582 (Leachi et al., 2005; Parsonage, 2008). This timestamp is found in the first 60 bits of the OID and is related to the start of the boot session in which the OID was created (Leachi et al., 2005). The two least significant bytes of this timestamp, when interpreted as Little Endian, are also used as a counter showing the order of OID creation within the specific boot session (Parsonage, 2008). The counter is the only two bytes that separates Object IDs assigned in the same boot session. The timestamp can be converted to FILETIME by subtracting the hex value 0x146BF33E42C000, allowing tools that interpret FILETIME to convert it. The OIDs have a clock sequence which will be identical for all OIDs created in a particular boot session. Finally the last 6 bytes of the OID will normally include the MAC address of the default Network adapter. If no NIC is available this will contain a random number (Leachi et al., 2005). A graphical illustration is shown in Fig. 1.Download : Download high-res image (220KB)Download : Download full-size imageFig. 1. Structure of an Object ID UUID version 1.
The Object ID is used as an index key in the $ObjId$O file and this Object ID is also located in the Object ID Attribute (type 0x40) in the corresponding MFT record. We can also find the MFT record number in the $ObjId$O index entry [2, p.335]. This way it is easy to find the correct record in the index, knowing the Object ID key from the MFT record, but also to find all Master File Table (MFT) records that have an Object ID by examining the $ObjId$O index entries. It is the latter approach that is presented in this paper. A prototype tool has been developed which implements this approach and was used during the course of these experiments.
The remainder of this paper is organized as follows. Section 2 describes related work. Section 3 illustrates the research goals. Section 4 describes the methodology and details about our experimental setup. Section 5 presents the results of our experiment. Section 6 presents the evaluation methodology and results of assessing the feasibility and reliability of the approach. Section 7 discusses and interprets the results. Finally, Section 8 concludes and provides recommendations for future work.
