Computer software, or computer code, is central to almost every aspect of our modern lives. However, little is known about the psychological aspects of code and the influences on why programmers choose to reuse specific code they did not create, given there are potential risks to reusing code. For example, the OpenSSL encryption many banks used for retaining secured connectivity was generally thought to be secure. However, Google's security team detected a serious issue in the software, known as Heartbleed (Grubb, 2014; Durumeric et al., 2014; CVE-2014-0160) that resulted in the theft of financial and personal data. The prevalence of code reuse and its associated risks suggest perceived code trustworthiness is an important psychological context that is under researched. Comments are an important aspect of computer code, particularly during code inspection (Porter et al., 1998). Comments should help the programmer navigate the code and understand its functional intent (Savitch, 2014). The current study sought to explore the role of code comments on how programmers perceive the trustworthiness of code.
1.1. TrustTrust has traditionally been thought of as an interpersonal construct. However, the literature has expanded the investigation of trust to organizations (Mayer et al., 1995), automation (Lyons et al., 2016), human-machine teaming (de Visser and Parasuraman, 2011), and websites (Flavian and Guinaliu, 2006). We extend the trust literature to focus on computer code. Trust can be separated into three aspects: trust beliefs, trust intentions, and trust actions (Jones and Shah, 2016). Trust beliefs are perceptions of a referent (i.e., perceived trustworthiness of the code). It is important to note, trust beliefs are not necessarily factually based, and thus may be inaccurate. Trust intentions are the willingness to be vulnerable, to someone or something. Trust actions are the behavioral reliance on the referent, such as reusing a piece of code. The current study focused on trust beliefs and trust actions.
1.2. Code reuseCode is a compilation of commands executed by a computer, written in a programming language, such as Java, C++, and C#. Although trained computer scientists and information technology professionals develop the software, code can get very complex and confusing as multiple systems are integrated. To expedite development, programmers often reuse code in new software. However, by integrating code previously written for other projects, programmers accept a certain level of risk and vulnerability. Programmers rely on both perfunctory perceptions and in-depth inspections of the code when deciding whether to reuse it. This cognitive evaluation is a perception of trustworthiness (Alarcon et al., 2017b). Psychological theories may help to illuminate the relationship between programmers and code. Future development of software could then encompass psychological engineering principles, improving end-product quality and efficiency in software production.Frakes and Kang (2005) defined code reuse as, “the use of existing software or software knowledge to construct new software” (p. 529). A recent article in CNET projected that roughly 80–90% of code is reused (Hautala, 2015). Code reuse indicates programmers perceived the code as trustworthy because they have integrated it into the program. Reusing code can increase productivity (Banker and Kauffman, 1991) and possibly produce better code, as the code has been previously tested and/or repeatedly updated (Lim, 1994). Much of the literature on code reuse arose from organizational and economic perspectives, highlighting the benefits of implementing reuse on a systemic level. By reusing code assets, programmers can forego the time and effort required to rewrite software (Banker and Kauffman, 1991). Reuse also allows for increases in the flexibility and complexity of code (Babar et al., 2004). However, reusing code may carry over software bugs that were not resolved in previous implementations (Hautala, 2015). Although research has demonstrated the usefulness of reusing code, little research to date has explored how programmers perceive code trustworthiness to pursue reuse.
1.3. Heuristic-systematic processing modelTrust in code is a relatively new field of research in psychology and computer science. Indeed, no theories or process models have been developed specifically for this area of research. Instead, we leverage research from the psychological literature. The heuristic-systematic model (HSM) describes how people process persuasive messages from an information processing perspective (Chaiken, 1980; Chen et al., 1999). Although the model was created to investigate the use of persuasion in contexts such as politics and consumer purchases, it can also be extended to investigate trust in code. The HSM postulates two types of processing that influence persuasion: heuristic processing and systematic processing. A heuristic is a “strategy that ignores part of the information, with the goal of making decisions quickly, frugally” (p. 454) than more intricate strategies (Gigerenzer and Gaissmaier, 2011). Heuristic processing involves retrieving task relevant rules or “heuristics” stored in memory. Heuristics are learned knowledge structures (e.g., norms, established procedures, rules of thumb; Chaiken et al., 1989). In comparison, systematic processing involves critical examination of information pertinent to decision making (Chen et al., 1999). Systematic processing is an in-depth examination of the referent or persuasive message. The two processes can occur separately or simultaneously, depending on the situation.One of the key tenets of the HSM is that when perceivers are processing information, they are interested in efficiency, looking to exert minimal effort in processing (Chen and Chaiken, 1999). Heuristic processing is efficient in cognitive effort and time, but typically at the expense of accuracy (Chaiken, 1980). In contrast, systematic processing requires more cognitive effort and time, but the decision rendered is more accurate (Chen et al., 1999). However, processing efficiency is not the only requirement for reaching a decision. The sufficiency principle states a perceiver has an actual level of confidence and a desired level of confidence, and actual confidence must be higher than desired confidence for a decision to be reached (Chen et al., 1999). The sufficiency threshold is when the level of actual confidence will satisfy the motives the perceiver is trying to meet. If the sufficiency threshold is met, the perceiver discontinues processing. If the threshold is not met, the perceiver will continue processing. The sufficiency threshold is not static, but can change given the motivation of the perceiver. Of the three motivations described by the HSM (Chen et al., 1999), accuracy motivation is the most relevant to programmers. In the context of programming, accuracy is key as ignoring minor issues may lead even a compiled program to fail execution tests or introduce security risks into a system. Accuracy motivation is the “open-minded and evenhanded treatment” of task-relevant information (Chen et al., 1999, p. 45). When accuracy motivation is low, the perceiver may utilize heuristic processing towards reaching a lower sufficiency threshold. In contrast, if accuracy motivation or cognitive resources are high, the perceiver may engage in systematic processing towards reaching a higher sufficiency threshold.Although the HSM was developed to assess constructs in social psychology, it can also be used to describe trust in code. Programmers are exposed to various principles and accepted practices for writing code such as readability, organized flow, and appropriate comments (Gaddis, 2016). These practices serve as cues for programmers to use when evaluating a piece of code they did not write. Specifically, these practices facilitate heuristic processing, and such processing can be leveraged when programmers read code. Code commonly referred to as “spaghetti code” does not follow these suggested practices, either from poor initial writing or from being changed by several programmers. We propose programmers use these cognitive heuristics initially to determine if the code is worth further evaluation. A recent cognitive task analysis (Alarcon et al., 2017b) identified three factors that influence trust in computer code: reputation, performance, and transparency. Reputation was defined as trustworthiness cues based on information provided outside the code, such as source, number of reviews, and number of users of the code. Performance was defined as the capability of the code to meet the necessities of the project. Transparency was defined as the perceived comprehensiveness of the code from viewing it. The focus of the current study is on transparency, specifically code commenting. Transparency, through organized and readable code in a well thought out architecture, should evoke heuristic processing leading to trust and reuse. Comments help to facilitate this heuristic processing.
1.4. CommentingIntroductory texts on programming often mention comments as an important aspect of the code (Gaddis, 2016; Wang, 2006). Commenting is a description of the code that is not part of the functionality of the code, but is placed in the code file. Thus, comments do not directly engage with the functionality of a program. From here on, we use “comments” to refer to the descriptions of the code and “instructions” to refer to the functional code, reserving “code” to refer to the combination of instructions and comments as the whole program. Comments can act as headers to describe the overall functional expectations of code (Johnfx, 2011). They can also decompose the instructions into logical segments (“Comment,” n.d.), generally highlighting where complex features may be present for easier inspection, integration, and maintenance, which may include alterations to the code given a change in domain, environment, or platform. When performing code reviews, between 20 and 35% of reviewers request additional documentation, including adequate commenting (Mäntylä and Lassenius, 2009; Beller et al., 2014). Code that requires additional documentation often appears to reviewers to have more defects (Porter et al., 1998; Thongtanunam et al., 2015), suggesting that well-commented code results in better overall instructions and long-term maintenance, as well as influences the perception of code reviewers. Comments may be used to indicate where issues exist that require modification to the instructions, where issues have been fixed, and how functionality is expected to be changed in future use, such as moving from a desktop to a mobile platform (“Comment,” n.d.). In a paper by Alarcon et al. (2017b), programmers stated that comments made the reviewer feel like the author “has my back,” indicating trust. Given the use of commenting and the accepted practices across all programming languages, we explored the role of commenting in trustworthiness perceptions of code. We classified comment characteristics into validity, placement, and style categories.Validity refers to the content of a comment and what it signifies. A comment should accurately and clearly describe the function or instruction to which it refers. Validity is similar to reliability in the trust in automation literature, in that reliability is the consistent relaying of accurate information (Lee and See, 2004). Reliability has been demonstrated to be an important aspect of trust in automation (Hancock et al., 2011; Madhavan and Wiegmann, 2007). Failures in automation have led to an increase in distrust in a system (Wiegmann et al., 2001). Similarly, invalid comments should decrease trust in code, whereas valid comments should increase trust. In addition, validity indicates the level of professionalism of the programmer, who should carefully express what is needed in the comment, providing clarity for future developers or other team members. As validity reflects the content of the comment, more valid comments should evoke heuristic processing leading to increased trust in code and decreased time exploring the code.In the current study, validity manipulations focused on the actual text and content of the comment and its relationship to the instructions. Comment validity was manipulated by 1) correctness, 2) wording of the comment, 3) maintaining TODO lists, and 4) pointless comments. First, incorrect comments are one factor of validity that can contribute to trustworthiness if the instruction is supposed to do something it does not. The second validity manipulation was how the comment was constructed. Sparsely worded comments may not provide enough information, potentially giving the reader a sense that the programmer was careless or that comments were added quickly after the fact. This may imply that the programmer was hasty on other aspects of the instructions. Third, often while coding, programmers will comment “TODO” in the code to describe what additional instructions need to be written. This method is used for both the lone programmer and for teams of programmers. These comments should be deleted when the instructions are inserted. If such comments remain in the code, it could appear that expected functionality is not available, that there was a problem with creating the functionality yet the code has been deployed, or that the programmer was just careless in not deleting the “TODO” as coding progressed. Lastly, if comments were provided but are pointless, it could be that the programmer was naïve, sloppy, or unconcerned about anyone reviewing the code, which could also mean that the instructions are sloppy and may contain execution errors.Hypothesis 1Comments with high validity will lead to increased trust beliefs.Hypothesis 2Comments with high validity will lead to less time assessing the code.Commenting placement is related to aesthetics and visibility, such as their physical presence and organization within the instructions, as well as their adherence to conventional placement strategies. For example, common practice dictates comments come before the method or function, rather than post function or method (Wang, 2006). In other words, if a comment describes a loop to be performed, it should be placed near the beginning of the loop to add clarity. This placement helps to differentiate aspects of the instructions (e.g., methods, functions). Odd comment placement, such as unstructured text alignment, or inefficient placement, such as overly long lines of comments that could have been easily blocked, can indicate a novice or quirky programmer. Too much commenting can indicate that a user may not know what should be said.We expected comment placement would facilitate heuristic processing. Abnormal alignment, length, and unnecessary wordiness of comments can lead to an immediate heuristic response that signals there is something strange about the comments. A significant number of oddities can be severe enough for outright distrust. Some oddities in placement will require a systematic process for further in-depth analysis of the comment itself and its relationship to the instructions. Once a comment is read, it should elucidate the aspect of the instructions it is referencing such as a method or function, a process that takes cognitive effort. Thus, placement heuristics should facilitate other systematic processing, making overall processing of the source code quicker. Proper placement will lead to greater trust and shorter time evaluating the instructions. Improper placement will lead to distrust and more in-depth analysis of the comments overall and the instructions as the reviewer attempts to decipher the code.Placement manipulations focused on the organization of the comments with respect to the instructions and how they are configured. First, the alignment manipulation forced the start of all comments to be exactly aligned at the end of instruction statements. This placement was coupled with using the “//” for comments taking multiple lines, leading to an alignment that was visibly unnecessary. Second, the indentation manipulation forced the start and continuation of comments to appear underneath the referenced instructions with the same indentation. This indentation could be performed using “//” or “/* <comment block> */” as it is after an instruction block or statement. Such indentation alignment could mean that the programmer was quirky and likes things unnecessarily structured or that the programmer possibly spent more time on perfecting the comment structure than on the instruction functionality. The third manipulation was line extension of the comment. Extending the line in a program past the instruction statement due to an overly lengthy comment causes visual issues by having to side-scroll while programming or reviewing the code and is thus frowned upon by experienced programmers.Hypothesis 3Comments with high placement properties will lead to increased trust beliefs.Hypothesis 4Comments with high placement properties will lead to less time assessing the code.Commenting style is related to the personal practices a programmer uses to write the comment, what aspects of the instructions should be or do not need to be commented, and the consistency with which comments appear throughout the code. The training a developer receives can influence their preferred commenting style. Also, style can be affected by the size and makeup of the team of developers working together. For example, a programmer that is writing solely for his or her own use may forgo consistently commenting functions, whereas a programmer that is involved in a team may over comment, including leaving unused and commented-out instructions within the program. Style provides visual cues that facilitate heuristic processing. In addition, style illuminates aspects of the code's author. Comments with adequate style indicate that the developer is knowledgeable in programming. This affords credibility to the source code author or authors, which has a long history in the social psychology literature as an antecedent to heuristic processing leading to persuasion (Chaiken and Maheswaran, 1994).Style manipulations consisted of the choices that programmers make to represent the comments in the code and the consistency with which they follow those choices. We used three conventions to represent style: (1) removing unused and commented out instructions, (2) consistently commenting major functions, and (3) using “//” for short comments and “/* <comment block> */” for multi-line comments. First, a common style choice is to comment out unused instructions or to delete them. Unused instructions may indicate multiple programmers have touched the code, or changes had to be made that might be uncertain. The second aspect of commenting style is whether the programmer consistently provided comments for major functions. This style choice may be due to the complexity of the function or laziness on the part of the programmer. The third style manipulation consisted of using “//” or “/*<comment>*/” for comments. Given the two methods to embed comments in Java code, experienced programmers that want to deliberately make multi-line comments usually choose the comment block method. Most often, single line comments are embedded with the double slash. However, programmers that throw in comments at the end of their coding time or are sloppy about commenting long sections might also choose the double slash method.Hypothesis 5Comments with high style will lead to increased trust beliefs.Hypothesis 6Comments with high style will lead to less time assessing the code.
