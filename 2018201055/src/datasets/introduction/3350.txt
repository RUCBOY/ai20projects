End-user programmers are individuals who create software without any formal training in software engineering methodologies. Millions [60] of them write simulations using LabVIEW [43], design websites using HTML, program web-applications using Yahoo Pipes[72], and design mobile applications using App Inventor [1], to name just a few popular platforms.
It is well known that end-user programmers learn by looking at and using examples [10], [47]. In fact, end users are known to opportunistically employ reuse while programming. A case study of more than four thousand mobile apps across five different categories in the Android Market revealed that on an average 61% of the classes appeared in two or more apps through inheritance, libraries, or frameworks [59]. To support such reuse, most end-user programming environments provide online repositories in which program variants are publicly archived. Evidence suggests that end users do make use of these repositories: previous studies [66] have found that more than 56% of the instances of code in repositories of end-user programs are clones. Another mechanism for reuse is to use programs as sub-programs in other applications. For example, in a study of Yahoo Pipes (a web mashup environment)1 it was found that 27.4% of the programs in the Yahoo Pipes repository had been used as sub-programs [39]. Thus, even though end users may view their programs as “throw away,” their code often ends up being long-lived and in many cases is reused by other end-user programmers [32].
End-user programmers’ requirements tend to be implicit, and emerge and change over time [32]. Often, requirements are poorly defined and there is no single way in which to satisfy them [68]. Moreover, while creating programs, end users’ design decisions and coding activities are typically interleaved [32]. Further, end users program opportunistically; i.e., they tend to select from alternative solutions that are available based on their own assessments of the strengths and weaknesses of those solutions [10]. Finally, end users tend to “debug their programs into existence” [58]; i.e., they investigate alternative strategies and backtrack through changes to arrive at solutions [40], [58].
Changing requirements, code reuse (“clone and own” and “accidental” sharing of code), and programming styles (opportunistic programming and debugging programs into existence) tend to create large numbers of program variants. While the provision of programs in repositories helps support end-user programming to an extent, finding appropriate variants remains a challenging task.
End-user programming environments typically do not provide facilities for managing variation. While developing applications, end-user programmers may have difficulties determining which variant of a program to begin with, which variant is the most recent, and which variants may have been created by other programmers in order to improve or extend their code. Professional software engineers use variation management systems to support code reuse, change traceability, and maintenance [21], [34]. Therefore, bringing the benefits of variation management into end-user programming environments is likely to empower end users with their programming tasks as well.
When considering variation management from the point of view of end-user programmers, we find it useful to distinguish two different ways in which variation occurs. In the first case, an end-user who has some “ownership” of a program may modify it or enhance it over time, creating new versions that replace prior ones, and essentially viewing the program as having a single, persistent identity. This is akin to developers working along a single line of successive releases of a product, or improving one of the products that makes up a product line. In the second case, an end-user may begin with an existing program, and essentially “clone” that program, also with the goal of enhancing or modifying it, but viewing it as the beginning of a new, independent line of programs. This is akin to developers creating a new permanent branch off an existing product, or adding a new product to a product line. In this work, we refer to all of the programs created in either of these fashions as “variants”, because they have shared provenance with some particular program, and we refer to programs created in the first manner as “versions”. In our earlier work [40], we showed that approaches for managing versions can be useful for end-user programmers. In this work we widen our focus to variants.
We hypothesize that by providing support for managing variants in addition to versions, we can enable end-user programmers to explore and understand structural and behavioral differences between different instantiations of programs. This, in turn, should help them create programs using variants of their choice as they can select alternative variants, try various combinations of variants, and appropriately mix features from different variants.
In this article,2 we first summarize the results of a survey that we conducted with the aim of understanding why and how end users create, find, and manage variants. Based on the survey results, we define a set of design requirements for programming environments that support the management of variants in end-user domains. We then describe AppInventorHelper, a prototype supporting variation over space in the App Inventor programming environment. With the help of visualizations provided by AppInventorHelper, end users can: (1) visualize all program variants at once, (2) view relationships between variants, and (3) select appropriate variants based on various parameters, such as code similarity, author, date of creation, and date of update. Finally, we report results of a formative user study that shows that AppInventorHelper can help users select appropriate variants and understand the differences and similarities among variants. We also explore which environment features facilitate or hinder selection of variants by end users.
Our work makes the following contributions:
1.We present the first study focusing on understanding the behavior of end-user programmers with respect to how they create, find, and manage variants of similar programs.2.We present data showing that a large percentage (88%) of end-user programmers report that they do create many program variants, while an almost equally large percentage (82%) of them do not use tools to track changes or manage variants; instead they rely primarily on memory to manage variants.3.We present design requirements for end-user programming environments to facilitate the management, and understanding of the provenance of, program variants.4.We implement our approach within the App Inventor environment. The visualization of program provenance provided by our implementation, however, generalizes to other programming environments because it does not rely on specific languages or tools.5.We present an evaluation of our environment that shows that it can help end-user programmers find and manage variants.6.We discuss implications for the design of future tools supporting variation management for end-user programming environments.
The remainder of this article is structured as follows. Section 3 describes our online survey and its results, and the design requirements it leads to. Section 4 describes our AppInventorHelper programming environment. Section 5 describes our empirical study design, and Section 6 describes the results obtained in the study. Section 7 describes the implications of our results for the design of environments supportive of variation management. Section 8 discusses related work, and Section 9 concludes.
