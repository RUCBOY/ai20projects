1.1. MotivationA universal concept in many disciplines is to characterize the behavior of an object, often called a module or a system, and thereby to intentionally ignore internal aspects considered irrelevant. We will here use the term system. The purpose of a system is to be used or embedded in an environment, which can for example consist of several other systems. A system's behavior is the exact characterization of the effect a system can have when embedded in an environment. In such a consideration, anything internal, not affecting the behavior, is by definition considered irrelevant, and two systems with the same behavior are considered to be equal. Which aspects are considered irrelevant, and hence are not modeled as part of the behavior, depends strongly on the concrete investigated question. For example, if for a software module computing a function, one is only interested in the input–output behavior, then this function characterizes the behavior of the software module, and aspects like the underlying computational model, the program, the complexity, timing guarantees, etc., are irrelevant. In another consideration, for example, one may want to include the timing aspects as part of the observable (and hence relevant) behavior. In yet another consideration one may be interested in the memory requirements for the specific computational model, etc.One can think of a system as connecting to the environment via an interface. More generally, if one wants to model a system composed of several (sub-)systems, then one can consider each system to have several interfaces and that systems can be composed by connecting an interface of one system with an interface of another system. The term “interface” is here used in the sense of capturing the potential connection to another system; it is indeed used in some contexts to refer to the specification of the behavior of an object, such as a software module, but here we use the term in a more general and more abstract sense. Our notion of connected systems corresponds to drawing a diagram with boxes, each having several lines (interfaces), and where some interfaces of systems are connected (by lines) and some interfaces remain free, i.e., accessible by the environment; see Fig. 1. A composed system appears to the environment as having only the free (not connected) interfaces and its behavior is observed only via these free interfaces; the internal topology becomes irrelevant and is not part of the behavior.Download : Download high-res image (30KB)Download : Download full-size imageFig. 1. A system composed of the four subsystems s1, s2, s3, and s4. Interfaces are labeled to allow specifying connections, e.g., i1 and j1 are connected, and s4 is not connected to the other systems. The resulting system has interfaces j2, j3, k3, and l1.In some applications, certain internal details of a system matter. One can then define the relevant internal aspects as being part of the behavior, to make them, by definition, visible from the outside. If too many internal details become relevant, our approach might be less suitable than directly using a model of systems that considers these internals. Indeed, a majority of existing work models systems by defining their internal operations, e.g., via states and transition functions. In many cases, however, such a detailed description of the internal operations is unnecessary and cumbersome, and our abstract approach would be beneficial. We now describe two examples for which ignoring internal details appear particularly useful.Distributed systems. In distributed systems, where systems are connected to other systems with which they can communicate, one is often interested in certain properties of the composed system. As an example, we present a simple impossibility proof of bit-broadcast for three parties with one dishonest party. This famous result was first proven by Lamport et al. [1], [2]; the proof we present here is in the spirit of that given by Fisher et al. [3]. This proof only requires that the involved systems can be connected and rearranged as described; the communication between them and how they operate internally is irrelevant. Ignoring these internal details not only simplifies the proof but also makes the result more general, e.g., it also holds if the systems communicate via some sort of analog signals.The goal of a bit-broadcast protocol is to allow a sender to send a bit such that all honest receivers output the same bit (consistency) and if the sender is honest, they output the bit that was sent (validity). Assume an honest sender uses the system sa for broadcasting a bit a∈{0,1}, and honest receivers use systems r1 and r2 that decide on a bit b1, and b2, respectively. If these systems implement a broadcast protocol with the required guarantees, each condition in Figs. 2a to 2d must hold for all systems e, which capture the possible behaviors of a dishonest party. Assume toward a contradiction that this is the case and consider the system in Fig. 2e. We can view the system in the dotted box composed of s0 and s1 as a system e in Fig. 2b to obtain b1=b2. We can also view the system in the densely dotted box composed of s0 and r1 as a system e in Fig. 2c to obtain b2=1. Finally, the system in the dashed box can be viewed as a system e in Fig. 2d, which implies b1=0, a contradiction. Hence, there are no systems s0, s1, r1, and r2 that satisfy these constraints. In Section 3.2, we provide a more formal proof within our theory.Download : Download high-res image (75KB)Download : Download full-size imageFig. 2. The impossibility of broadcast for three parties with one dishonest party. Figs. 2a to 2d correspond to the requirements for a broadcast protocol. Fig. 2e can be subdivided in different ways and is used in the proof. Interface labels are omitted to increase readability.Cryptography. Cryptographic schemes are often defined as some sort of efficient algorithms. While efficiency is of course relevant in practice, one can separate the computational aspects from the functionality to simplify the analysis. Constructive cryptography by Maurer and Renner [4], [5] allows one to model what cryptographic protocols achieve using a system algebra that abstracts away cumbersome details. To this end, one considers so-called resource systems, which provide a certain functionality to the parties connected to their interfaces, and converter systems, which can be connected to resources to obtain a new resource. Typical resources with interfaces for two honest parties and an adversary are a shared secret key, which provides a randomly generated key at the interfaces for the honest parties and nothing at the interface for the adversary,4 and different types of channels with different capabilities for the adversary. The goal of a cryptographic protocol is then to construct a resource S from a resource R. Such a protocol consists of a converter for each honest party, and it achieves the construction if the system obtained from R by connecting the protocol converters to the interfaces of the honest parties is indistinguishable from the system obtained from S by connecting some converter system, called simulator, to the interface of the adversary. The notion of indistinguishability can be defined in several ways leading to different types of security, e.g., as the systems being identical or via a certain class of distinguishers.A crucial property of this construction notion is that it is composable, i.e., if some protocol constructs a resource S from a resource R and another protocol constructs a resource T from S, these protocols can be composed to obtain a construction of T from R. Turned around, one can also decompose the construction of T from R into two separate constructions. Since these two constructions can be analyzed independently, this approach provides modularity and simplifies the analysis of complex protocols by breaking them down into smaller parts.An example of a construction is that of a secure channel, which leaks only the length of the sent messages to the adversary and does not allow modifications of them, from the resource consisting of a shared secret key and an authenticated channel, which leaks the sent messages to the adversary but also does not allow modifications of them, by a symmetric encryption scheme. See Fig. 3 for an illustration of the involved systems. To achieve this construction, the simulator must, knowing only the length of the sent messages, output bit-strings that are indistinguishable from encryptions of these messages. If the used encryption scheme is, e.g., the one-time pad, the two systems in Fig. 3 are identical for an appropriate simulator, i.e., they have the same input–output behavior [5], which provides the strongest possible security guarantee. Note that internally, these systems are very different, but this is intentionally ignored.Download : Download high-res image (49KB)Download : Download full-size imageFig. 3. The systems appearing in the construction of a secure channel from an authenticated channel and a shared secret key via symmetric encryption. The construction notion requires the two systems in the dashed boxes to be indistinguishable.
1.2. ContributionsWe develop a theory of systems with different levels of abstraction. To achieve generality and to strive for simplicity, theorems are proved at the highest level of abstraction at which they hold. See Fig. 4 for an overview of the types of systems we consider. This is not meant to be a complete picture of all systems one can consider; systems we do not consider in this paper but could be treated within our theory include probabilistic systems, physical systems, circuits, etc.Download : Download high-res image (65KB)Download : Download full-size imageFig. 4. The hierarchy of the systems treated in this paper, where systems at lower levels are special cases of their parents.Abstract system algebras and composition-order invariance. At the highest level of abstraction, we do not specify what systems are, but only postulate two operations ∥ and γ, depicted in Fig. 5; the former for combining two systems in parallel as in Fig. 5a and the latter for connecting interfaces as in Fig. 5b. Using these operations one can build “graphs” such as those depicted in Fig. 1, by first taking the systems in parallel and then connecting the interfaces. We call a set of systems together with these operations, and the specification which interfaces a system has and which of them can be connected, a system algebra, see Section 3.Download : Download high-res image (48KB)Download : Download full-size imageFig. 5. Composition operations in a system algebra.A natural property of such an algebra that can be specified at this level of abstraction is composition-order invariance, that is, a composed system is completely described by its “graph”, and the order in which the operations are applied to build the graph does not matter. This property is not only very natural, but also necessary for many applications. For example, the impossibility proof for broadcast sketched above relies on it since otherwise, rearranging and subdividing systems as in Fig. 2e would not be allowed. To illustrate this, we formalize the systems occurring in that figure in an abstract system algebra and show how composition-order invariance appears in the proof in Section 3.2. Composition-order invariance was also used by Maurer and Renner to prove the composition theorem of constructive cryptography [4]. While appearing natural and innocent, examples throughout our paper indicate that composition-order invariance is actually a nontrivial property and requires a proof.Functional system algebras. An important type of system in computer science takes inputs and produces outputs depending on these inputs. The behavior of such a system can be fully described by a function mapping inputs to outputs. We define a type of system algebra, called functional system algebra, in Section 4.1 where the systems have input interfaces and output interfaces and correspond to such functions. Connecting an input interface to an output interface is understood as setting the value input at the former to be equal to the value output at the latter. Determining the resulting system thus involves finding a fixed point of the underlying function; if multiple fixed points exist, the system algebra has to specify which one to select. By appropriately choosing the domains and functions, various types of systems can be modeled in this way, including interactive systems that take many inputs in different rounds and systems that depend on time.We prove several basic results at this level of abstraction, i.e., without specifying which functions are considered in Section 4.2. For example, we show that not all functional system algebras are composition-order invariant, but if there are always unique fixed points for interface connections and connections can be reordered, composition-order invariance holds.While this paper focuses on the deterministic case, we point out that functional systems can be used as a basis to model probabilistic systems. For example, one can consider systems that take randomness as an explicit input at a dedicated interface, one can include random variables in the domains of the functions, or one can consider probability distributions over deterministic systems. Systematically understanding probabilistic systems in this way is future work.Instantiations of functional system algebras. To instantiate the concept of a functional system algebra, we need to specify the domains of the functions and the set of functions to consider. To be able to define the interface connection, we have to ensure that all functions have the required fixed points. One way to guarantee fixed points that is well-studied in mathematics, especially domain theory, is to equip the domain with a partial order such that all chains have a supremum and to consider monotone functions. A related concept are continuous functions, which are defined as preserving these suprema. In both cases the functions have a least fixed point. While continuity is a stronger requirement than monotonicity, a slightly weaker assumption on the domains is sufficient to guarantee least fixed points. We show in Section 5.1 and Section 5.2 that if least fixed points are chosen for interface connections, monotone and continuous functions form a functional system algebra, respectively. Under the additional assumption that nonempty chains have an infimum, we show in Section 5.3 that these system algebras are composition-order invariant.Monotone and continuous functions are not only a mathematical convenience to obtain fixed points, but they also encompass as a special case an intuitive and useful model known as Kahn networks [6] (or Kahn process networks; in Kahn's paper only defined for continuous functions, but monotone functions can be used as well), which we consider in Section 5.4. Kahn networks have been developed to provide a semantics for parallel programming languages [6], but they have also been used in other contexts, including embedded systems [7] and signal processing [8]. The domains of the functions there consist of sequences of values and the partial order is defined to be the initial segment (or prefix) relation. An interpretation of a function is that it maps input histories to output histories. Such functions therefore correspond to interactive systems that take one input after the other at each input interface and produce outputs depending on the inputs. Monotonicity means that additional inputs can only yield additional outputs, an output cannot be “taken back”. Even though it appears to be a very natural question whether the order in which interfaces of Kahn networks are connected matters, we are not aware of any result in this direction. Our proof of composition-order invariance, which indeed turned out to be nontrivial, therefore also provides new insights into this well-studied model.In Section 6, we finally provide an instantiation of functional system algebras consisting of causal systems in which inputs to the system can only influence “later” outputs. We formalize this by considering a partially ordered set (where “less than” can be interpreted as “before”) and letting the domains of the functions consist of subsets thereof. As an example, consider the partially ordered set containing pairs (v,t), which can be interpreted as the value v being input (or output) at time t, where the order is naturally defined as the one induced by the second component. The domains are then sets of such pairs. This allows us, as for Kahn networks, to model systems that take several inputs at each input interface and produce several outputs. We define causality for such systems and prove that the corresponding functions have unique fixed points. Therefore, we obtain a composition-order invariant functional system algebra. This system algebra can in particular be used to model and analyze systems that depend on time, such as clocks and channels with certain delays.
1.3. Related workThere exists a large body of work on modeling certain types of systems mathematically. Some models can be understood as special cases in our theory, but also very general theories and models that do not fit in our theory exist. The work we are aware of, however, only captures partial aspects of our theory. We now describe some of this work and compare it to ours.Abstract models. The abstract concept of a system algebra in which complex systems are built from components has been informally described in the context of cryptography by Maurer and Renner [4]. They also, again informally, introduced composition-order independence, which corresponds to our composition-order invariance. We provide in this paper a formalization that matches their requirements.Hardy has developed an abstract theory, in which composition-order invariance (there called order independence) plays an important role [9]. That work, however, focuses on physical systems. Lee and Sangiovanni-Vincentelli [10] also introduce an abstract system model, but it is specific to systems that consider some form of time and does not follow an algebraic approach.Closely related to our abstract system algebras are block algebras as introduced by de Alfaro and Henzinger in the context of interface theories [11]. Our systems and interfaces are there called blocks and ports, respectively, and they also define parallel composition and port connection operations. A major difference compared to our system algebras is that port connections do not hide the connected ports. Moreover, while de Alfaro and Henzinger require the parallel composition to be commutative and associative, they do not define a notion that corresponds to our composition-order invariance, i.e., their port connections not necessarily commute with other port connections and parallel composition.Process algebras allow the modeling of communicating concurrent processes [12], which correspond to our systems. Examples of process algebras include Milner's Calculus of Communicating Systems (CCS) [13] and Hoare's Communicating Sequential Processes (CSP) [14]. These theories are similar to ours in that they consider certain operations, including parallel composition, on processes and postulate axioms they need to satisfy. These axioms also include guarantees similar to our composition-order invariance. In contrast to our theory, CCS does not have an explicit operation for connecting interfaces, there called ports. Rather, ports with matching labels are implicitly connected when systems are taken in parallel. As in the work by de Alfaro and Henzinger [11] discussed above, ports are not hidden by this connection; hiding them is an explicit operation in CCS. In CSP, processes communicate via special input and output commands. As opposed to our abstract level, these process algebras differentiate between inputs and outputs and allow to specify the behavior of processes. Thus, with respect to the level of abstraction, they belong somewhere between our abstract and functional levels, or even below.Milner's Flowgraphs [15] model composed systems as generalized graphs, in which the nodes correspond to subsystems. This is considerably different from our theory since we abstract away all internal details of a system, in particular the subsystems that compose a system.Functional models. A line of work on system models based on functions has been initiated by Kahn's seminal paper [6] on networks of autonomous computing systems. These systems may be sensitive to the order in which messages arrive on one interface, but they are oblivious to the relative order of incoming messages on different interfaces. He shows that least fixed points exist, based on earlier work by Tarski [16], Scott [17], and Milner [18],5 and therefore connecting systems is well-defined. Tackmann [20] considered the case where systems are fully oblivious to the order of their incoming messages, which can be seen as a special case of Kahn networks where each interface contains at most one message. Micciancio and Tessaro [21] start from the same type as Kahn but extend it to tolerate certain types of order-dependent behavior within complex systems.Timed models. Several works have defined causal system models. Lee and Sangiovanni-Vincentelli [10] define delta causality, which intuitively requires that each output must be provoked by an input that occurred at least a δ-difference earlier. They show that fixed points exist, based on Banach's theorem. Cataldo et al. [22] generalize this to a notion of “superdense” time where multiple events may occur simultaneously. Portmann et al. [23], in the quantum scenario, describe a type of strict causality based on a causality function that can be seen as a generalization of delta causality. Naundorf [24] considers strict causality without any minimal time distance, and proves that fixed points still exist. Matsikoudis and Lee [25] then show a constructive fixed point theorem for the same notion, which they refer to as strictly contracting. They show that it is implied by a more natural notion of (strict) causality where outputs can be influenced only by inputs that occur strictly earlier, under the assumption that the ordering of inputs is well-founded.6 We show in Appendix A that the strict causality notion of [25] is essentially equivalent to the definition we introduce in this work.Except for the work of Portmann et al., none of the previously mentioned definitions of causal functions explicitly capture systems with multiple interfaces as the work of Kahn [6] or our work. Also, the mentioned papers investigating causal functions do not define how to connect systems such that one obtains a system of the same type, and therefore they do not provide a system algebra as we do. The model by Portmann et al. [23] captures quantum information-processing systems and can be seen as a generalization of our causal systems. Restricting that model to classical, deterministic inputs and outputs yields, however, a more complex and less general model than our causal systems. For example, the causality definition in that paper is more restrictive and in contrast to our causal systems, the systems there are not allowed to produce infinitely many outputs in finite time.Partial orders have also been used to model causal or temporal dependencies, for example in Pratt's theory of partially ordered multisets (pomsets) [26], [27]. As in our causal systems, there is a partial order on the possible events. In contrast to our causal systems, however, systems in that theory are not necessarily functions and can exhibit nondeterminism. Our model is therefore more specific, which allows a more accessible presentation.Stateful models. Several models of systems have been proposed that model the systems as objects that explicitly contain state. I/O automata initially discussed by Lynch and Tuttle [28] and interface automata by de Alfaro and Henzinger [29] enhance stateful automata by interactive communication. Timed automata by Alur and Dill [30] and timed I/O automata by Kaynar et al. [31] extend them to include a notion of time as our causal systems. Interactive Turing machines basically equip Turing machines with additional tapes that they share with other machines and have been used widely in (complexity-theoretic) cryptography [32], [33]. All these models are substantially different from ours since we want to hide all internal details of systems, including their state.
