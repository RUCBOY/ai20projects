Querying whether a point is inside a solid or not is one of the basic algorithms in geometric modelling. This algorithm is used in many applications such as computing Boolean operations [10], ray-casting visualization [6], collision detection [21] or, specifically in 2D, for trimming surfaces [24], among others. In this work we focus on solids represented by triangular meshes because this type of mesh is widely used for representing the boundary of solids in 3D since triangular meshes are simple and the pipeline of current graphic hardware is optimized for the visualization of triangles. The inclusion test for triangular meshes is also used as part of inclusion tests in more complex solids, such as those defined by free-form surfaces [[3], [23]].
The most popular point inclusion technique is based on the Jordan Curve Theorem [20]. This method shoots a semi-infinite ray from the point and counts the number of intersections with the boundary of the solid. If this number is odd, the point is inside; if the number of intersections is even, the point is outside. This ray-shooting algorithm can be optimized by calculating a spatial structure that avoids performing the ray-triangle test for all the triangles in the solid. BSP, octree and layer-based representations are well-known examples of data structures used for this purpose [[13], [19], [27]]. Using this type of spatial structure implies an extra effort of both time preprocessing and data storing. If the mesh has a high number of triangles or a complex shape (many concavities), the size of the spatial structure could exhaust the system resources. If the mesh has a low number of triangles, the preprocessing time of the spatial structure could not compensate the speedup over the algorithm without preprocessing. Detailed studies that revise the pros and cons of using spatial structures for optimizing the inclusion test can be found in [19]. The ray-shooting algorithm is very simple, but has several special cases when the ray is coplanar to some vertex, edge or face [9]. Several recent studies address this problem, but either the overall solution is inefficient [2] or not all the situations that present special cases can be managed [12].
One of the most cited point-in-polyhedron algorithms is the one presented by Feito and Torres in [5]. This algorithm was further simplified for triangular meshes in [25]. This algorithm is very simple. Each triangle of the mesh and the origin define a tetrahedron. The point inclusion test is performed individually in each one of these tetrahedra, and the individual results over each tetrahedron are combined by a simple sum to obtain the final result over the whole triangular mesh. This algorithm is robust and valid for manifold and non-manifold objects and all the special cases are easily managed. Feito and Torres’s algorithm can also take advantage of spatial structures in order to optimize its performance [[14], [19]], but again the main problem of using these structures is the preprocessing time needed to calculate them.
There is little work about optimizing the point inclusion test on GPU. Two reasons for this fact could be: (1) most algorithms have to solve special cases and this does not fit the parallel processing model of GPUs well; and (2) data structures for algorithms with pre-processing add high memory requirements for complex models, and this situation is also not well suited for the limited space of the GPU memory. However, as we have discussed, the point inclusion test is the base algorithm for many other processes and there are several applications that use it very intensively. Therefore, providing an efficient and robust GPU-based solution is very useful. There are several previous studies that have presented GPU implementations of the point in polyhedron test for triangular meshes [[8], [12], [15], [22]]. Jiménez et al.’s algorithm [8] uses a spatial data structure (tetra-tree) to accelerate their shader-based test. However, the tetra-tree structure has to be calculated in the CPU along as some special cases of the algorithm which cannot be solved by their GPU implementation. The approaches introduced in [15] present the similar drawback in [8] of needing to solve some special cases of the algorithm in CPU. In that study an out-of-core shader-based algorithm is also provided. This implementation does not use the tetra-tree structure, so no pre-processing is needed. However, CPU–GPU transfers needed in this algorithm prevent from obtaining a better performance. In [22] a CUDA implementation of Feito and Torres’s algorithm is presented. In this implementation, each thread computes the inclusion test of several points against the entire mesh. Techniques such as local storing of triangles into GPU registers and interleaving the memory accesses of the threads allow speedups of up to 77× to be obtained against a CPU single-thread implementation of the same algorithm. The algorithm presented in [12] is based on ray-shooting and uses a grid as a spatial structure to avoid counting most of the ray-triangle intersections. This algorithm executes very fast and clearly outperforms the GPU implementation in [22]. However, Li and Wang’s algorithm still presents two limitations inherent to ray-shooting algorithms: (1) non-manifold objects cannot be managed and (2) the special case of a ray coplanar to a face cannot be processed in some situations, for example, for a polyhedron with a large face coplanar to the ray where all the centre points of the cells of the grid in the direction of the ray are singular (coplanar to the face).
In this paper we further explore the GPU implementation of Feito and Torres’s algorithm because it can naturally manage general triangular meshes (manifold and non-manifold), and all the special cases can be easily detected and processed. Our approach is based on a very simple point-in-tetrahedron test that does not need any branching operation. As a result, our new GPU algorithm performs robustly and faster than previous GPU implementations of the same algorithm.
