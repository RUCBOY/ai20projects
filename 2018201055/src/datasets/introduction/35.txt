Scientific software development refers to the analysis, design, implementation, testing, and deployment of software applications for scientific purposes (e.g., physics, biology, medical analysis, and data science). The need for continuous experimentation and validation of techniques (e.g., simulations and cases studies) before the release of scientific results has led to the emergence of the domain of scientific software development as an important method for researchers to be successful in multiple fields (Birdsall and Langdon, 1991). As a result, “many scientists and engineers spend much of their lives writing, debugging, and maintaining software, but only a handful have ever been taught how to do this effectively: after a couple of introductory courses, they are left to rediscover (or reinvent) the rest of programming on their own. The result? Most spend far too much time wrestling with software, instead of doing research, but have no idea how reliable or efficient their programs are”. Wilson (2006). While this quote is 15 years old, the sentiment has not changed. If anything, the dependence upon software has increased within the scientific domain while scientists are still not well-equipped.
The US National Science Foundation (NSF) has awarded more than US$9.6 billion to support more than 18,000 projects and 95% of postdocs surveyed report the use software (that in most of the cases they have developed themselves) to support their research (Nangia and Katz, 2017). In addition, a recent blog post describing the results of a survey of 1200 researchers funded by the US NSF showed that the vast majority of respondents did not have sufficient time for training and that most development activities (other than coding) were not well-supported by current development tools (Carver, 2019). Although scientists invest a large fraction of their time (more than 40%) to building software, they often do not take full advantage of the advancements in software engineering (SE) (Heaton and Carver, 2015). This lack of SE practices can be attributed, at least partially, to limited knowledge of the benefits of these practices (Schmidberger and Brügge, 2012). Only about half of the postdocs from the survey mentioned earlier had received any software development training (Nangia and Katz, 2017) and 75% of NSF-funded researchers reported no time for training (Carver, 2019). As one specific example, only about half of scientists know the basics of testing (Wilson, 2006).Download : Download high-res image (386KB)Download : Download full-size imageFig. 1. State of practice and envisioned practices in scientific software development.
Based on the findings above, the left side of Fig. 1 highlights some issues that arise when scientific software developers lack proper SE practices. The text below explains these issues in more detail:

•Management of Large Code-bases and Collaboration. Scientific software applications can be complex, often containing millions of lines of code (Méndez et al., 2014). Projects of this complexity cannot be developed by a single person. Therefore, scientific software developers need to use collaborative software development approaches and tools. In addition, projects of this scale are often multi-disciplinary (Howison and Herbsleb, 2011), which also increases the need for collaboration. For example, development of a full-scale application can require input from scientists with different expertise (e.g., mathematicians, biologists, natural scientists, etc.).•Maintainability. New development is only a portion of the software lifecycle. Because maintenance activities can consume 50% to 75% of a project cost, it is important to keep maintenance costs low (van Vliet, 2008). In fact, teams “waste” up to 25% of development time during maintenance, due to technical debt (Martini et al., 2018). Similarly, scientific software projects see maintainability as an important goal because (a) maintenance is costly in terms of productivity and loss of vital scientific work; and (b) Exascale applications are usually written in C, C++, or FORTRAN, which offer high performance but are difficult to evolve and maintain (Schmidberger and Brügge, 2012).•Reuse Opportunities. Productivity is one of the main concerns for scientific software projects (Faulk et al., 2009). One way to improve productivity (i.e., reduce development time) is through software reuse. Because some algorithms are common across projects, especially within a domain, reuse of code should be a helpful approach. As evidence of the potential for reuse, some scientific software projects have explored Software Product Lines, an advanced reuse technique (Costa et al., 2015).
To address these limitations, scientific software developers could benefit from the advances in SE as illustrated in the right side of Fig. 1. For example, collaboration among developers and the management of large codebases, could be performed through tools like git and Jenkins (Omar et al., 2014); quality monitoring (especially focusing on Technical Debt) could be performed with SonarQube (Ampatzoglou et al., 2015); and reusability could be facilitated with the use of practices such as refactorings and design patterns (Ampatzoglou et al., 2011). All the above tools could be synchronized by using well-known methodologies for managing software development lifecycles, such as Agile practices (Unhelkar, 2013).
Based on the expected benefits of using SE practices in scientific software development1 , there is a growing interest among scientific software developers to cultivate a culture of SE within their community. This growing interest has begun to impact the literature in this domain. There are papers that report techniques and tools for improving the development of scientific software. Therefore, the goal of this study is to provide a detailed mapping of the current state-of-research and -practice about the use of SE in scientific software development. To properly scope this broad topic, we define three more specific goals: (G1) investigate the SE practices currently used in scientific software development; (G2) identify the quality attributes that drive the use of SE practices2 ; and (G3) assess the level of empirical evidence that supports the impact of SE practices on quality attributes. To achieve these goals, we conducted a Systematic Mapping Study (SMS), focused on classification and categorization of primary studies to provide first understanding of the domain.Table 1. Related work overview.ReferenceResearch method# papersReview periodG1 - SE practicesG2 - Software qualitiesG3 - Empirical evidenceAdditional goalsHeaton and Carver (2015)SLR43through 2015XXSletholt et al. (2011)SLR82000–2011XImpact of agile to testing and requirements activitiesSletholt et al. (2012)5Farhoodi et al. (2013)SMS1301996–2011XXBibliometricsKanewala and Bieman (2014)SLR62until 2013XDefinition and challenges of scientific software developmentQueiroz and Spitz (2016)SLR221Until 2015PartiallyPartiallyGUI design guidelinesGamification principlesPflüger et al. (2016)SLR331990–2015PartiallyXTrade-offs between the QAsOur StudySMS359through 2019XXX
