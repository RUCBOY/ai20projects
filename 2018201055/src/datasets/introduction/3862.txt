1.1. The Gray codeThe Gray code, or more precisely, the reflected binary Gray code Gn, orders the 2n binary strings of length n in such a way that successive strings differ in a single bit. It is defined inductively as follows, see Fig. 1a for an example. The Gray code G1=0,1, and if Gn=C1,C2,…,C2n is the Gray code for the bit strings of length n, then(1)Gn+1=0C1,0C2,…,0C2n,1C2n,1C2n−1,…,1C2,1C1. In other words, we prefix each word of Gn with 0, and this is followed by the reverse of Gn with 1 prefixed to each word.Download : Download high-res image (165KB)Download : Download full-size imageFig. 1. (a) The binary Gray code G6 for 6-tuples. (b) The ternary Gray code for 4-tuples, as considered in Section 4 and defined in Section 5.
1.2. Loopless algorithmsThe Gray code has an advantage over alternative algorithms for enumerating the binary strings, for example in lexicographic order: one can change a binary string anan−1…a1 to the successor in the sequence by a single update of the form ai:=1−ai in constant time. However, we also have to compute the position i of the bit which has to be updated. A straightforward implementation of the recursive definition (1) leads to an algorithm with an optimal overall runtime of O(2n), i.e., constant average time per enumerated bit string, which is optimal.A stricter requirement is that the worst-case time between two successive strings is constant. Such an algorithm is called a loopless generation algorithm. We will discuss this concept more thoroughly in Section 2. Different loopless algorithms for Gray codes are known, see Bitner, Ehrlich, and Reingold [1] and Knuth [2, Algorithms 7.2.1.1.L and 7.2.1.1.H]. These algorithms achieve constant time by maintaining additional pointers in a smart way.
1.3. The Tower of HanoiThe Tower of Hanoi is the standard textbook example for illustrating the principle of recursive algorithms. It has n disks D1,D2,…,Dn of increasing radii and three pegs P0,P1,P2, see Fig. 2. The goal is to move all disks from the peg P0, where they initially rest, to another peg, subject to the following rules:1.Only one disk may be moved at a time: the topmost disk from one peg can be moved on top of the disks of another peg.2.A disk can never lie on top of a smaller disk.Download : Download high-res image (108KB)Download : Download full-size imageFig. 2. The Tower of Hanoi with n = 6 (square) disks. When running the algorithm HANOI from Section 1.5, the configuration in this picture occurs together with the bit string 110011. (The relation between the positions of the disks and this bit string is not straightforward, cf. [3, Section 3].) The next disk to move is D1; it moves clockwise from peg P2 to P0, and the last bit is complemented. The successor in the Gray code is the string 110010. After that, D1 pauses for one step, while disk D3 moves clockwise from P1 to P2, and the third bit from the right is complemented, leading to the string 110110.For moving a tower of height n, one has to move disk Dn at some point. But before moving disk Dn from peg A to B, one has to move the disks D1,…,Dn−1, which lie on top of Dn, out of the way, onto the third peg. After moving Dn to B, these disks have to be moved from the third peg to B. This reduces the problem for a tower of height n to two towers of height n−1, leading to the following recursive procedure.Download : Download high-res image (56KB)Download : Download full-size image
1.4. Connections between the Tower of Hanoi and Gray codesThe delta sequence of the Gray code is the sequence 1,2,1,3,1,2,1,4,1,2,1,… of bit positions that are updated. (In contrast to the usual convention of numbering the bits starting from 0, we start at 1.) This sequence has an obvious recursive structure which results from (1). It also describes the number of changed bits when incrementing a number from j to j+1 in binary counting. Moreover, it is easy to observe that the same sequence also describes the disks that are moved by the recursive algorithm MOVE-TOWER above. It has thus been noted that the Gray code Gn can be used to solve the well-known Tower of Hanoi puzzle, cf. Scorer, Grundy, and Smith [3, Section 5] or Gardner [4]. The delta sequence does not specify the direction of movement, but this can be easily recovered, see Proposition 1 below. Conversely, the Tower of Hanoi puzzle can be used to generate the Gray code Gn, see Buneman and Levy [5].Several loopless ways to compute the next move for the Tower of Hanoi are known, and they lead directly to loopless algorithms for the Gray code. We describe one such algorithm.
1.5. Loopless Tower of Hanoi and binary Gray codeFrom the recursive algorithm MOVE-TOWER, it is not hard to derive the following fact.Proposition 1If the tower should be moved from P0 to P1 and n is odd, or if the tower should be moved from P0 to P2 and n is even, the moves of the odd-numbered disks always proceed in forward (“clockwise”) circular direction: P0→P1→P2→P0, and the even-numbered disks always proceed in the opposite circular direction: P0→P2→P1→P0.  □In the other case, when the assumption does not hold, the directions are simply swapped. Since our goal is not to move the tower to a specific target peg, but to generate the Gray code, we stick with the proposition as stated.Download : Download high-res image (64KB)Download : Download full-size image To obtain the Gray code, we simply set ak:=1−ak whenever we move the disk Dk. See Fig. 2 for a snapshot of the procedure. We would not need the clockwise/counterclockwise rule for Dk: Since we must not put Dk on top of D1, there is anyway no choice of where to move it [5]. We have chosen the above formulation since it is better suited for generalization (Section 7).
1.6. OverviewIn this paper, we will generalize the connections between Gray codes and the Tower of Hanoi to Gray codes for larger radixes (alphabet sizes). Section 4 is devoted to ternary Gray codes and their connections to the so-called Towers of Bucharest. After defining Gray codes with general radixes in Section 5, we extend the ternary algorithm from Section 4 to arbitrary odd radixes m in Section 6, and even to mixed (odd) radixes (Section 8). In Section 7, we generalize the binary Gray code algorithm HANOI from above to arbitrary even m. Finally, in Section 10, we develop loopless algorithms based on an entirely different idea of “working ahead” that is related to converting amortized running-time bounds to worst-case bounds. The introductory Section 2 discusses the concept of loopless algorithms in greater depth, and should dispel any hopes that the reader might have of finding something that would be of great practical value. Section 3 mentions fast computer hardware operations as an alternative option for generating Gray codes and sets our topic apart from such practices. In the brief remainder of the introduction, Section 1.7, we prepare the readers' minds for the primary “model of computation” that we will use. In the concluding section, Section 11, we will reflect our results and how they were achieved, and we will indicate some open problems.These results were presented at the 8th International Conference on Fun with Algorithms (FUN 2016) in La Maddalena island off Sardinia in June 2016 [6]. The preprint [7] contains prototype simulations of all our algorithms in the programming language Python.
1.7. Algorithms without computersThe algorithm HANOI does not run on a conventional computer but on a different piece of hardware (Fig. 2). We will show more such examples. Of course, it is easy to translate these algorithms into “simulations” on the electronic computers to which we are so accustomed. However, we encourage the readers to join us in thinking directly about algorithms for this restricted world, namely, looking at stacks of disks on different pegs.This relates to the CS-Unplugged1 project (Computer Science without a computer) in the context of educating children about Computer Science, and it underlines the point that Computer Science, or Informatics, as it is more appropriately called in other languages, is not the science of computers. “Computer Science is no more about computers than astronomy is about telescopes” is a saying which often attributed to E. W. Dijkstra, but which apparently goes back to Mike Fellows. In the case of astronomy, it must of course be conceded that telescopes, and more generally, devices and procedures for physical measurements, are eminently relevant. Similarly, there is an important part of Computer Science that deals with the design, the organization, and the use of computers. However, a core part of Computer Science, in particular in theoretical computer science and the analysis of algorithms, is concerned with ideas that are separate from the physical embodiment in electronic computers. One can even argue that a major effort of Computer Science (programming languages, operating systems) consists in providing layers of abstraction that help to avoid direct contact with computers.
