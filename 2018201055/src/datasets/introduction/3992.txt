Probabilistic graphical models (PGMs) can be viewed as a unification of graph theory with probability theory into a new formalism for multivariate statistical modeling [1]. It provides a convenient way of integrating perception and action as well as learning and planning which are basic requirements for almost all artificial intelligence (AI) manifestations. This formalism can be characterized as a graph of relations between the involved state variables (i.e., the inferred data) and the observations (i.e., the evidence) [2], [3]. In control systems and robotics, PGMs are best suited for higher level control algorithms, although it offers a convenient method for multi-level integration, from low-level control to high-level rule-based planning in the domain of relational statistics [4], [5], [6].
The graph in PGMs may be directed (e.g., a Bayesian or Belief network), or undirected (i.e., generally known as a Markov random field). Directed graphs are useful for expressing causal relationships between random variables, whereas undirected graphs are better suited to express soft constraints between random variables [7]. In robotics, for example, it is common to use a computer vision technique as a means of gaining information about the state of the world, and to use some form of Kalman filters to infer its own internal states to trigger the robot motion. In this scenario, the undirected graph is the right model for handling the vision processing, whereas the directed graph is the right one for modeling the robot motion through some paths or trajectories.
There is an increasing trend in this decade to merge/combine both directed and undirected graphs into one unified formality. One of the emerging models resulting from such a unification is called the factor graph model. In general, a factor graph represents function’s factorizations of several random variables [8]. In its original form, it is an undirected graphical model, but in its inference, it behaves in the same way as a directed model. Because of this inheritance aspect, for a factor graph that has an underlying functionality originating from a Bayesian network, it is usually possible to use an inference mechanism such as belief propagation (BP).
Factor graphs have attracted the attention of many researchers and engineers in recent years because of the wide variety of algorithms that have been developed in AI, signal processing, and digital communications, can be expressed using factor graphs. These developments can be derived as specific instances of the BP algorithm running on factor graphs, including the forward/backward algorithm, the Viterbi algorithm, the iterative “turbo” decoding algorithm, Pearl’s belief propagation algorithm for Bayesian networks, the Kalman filter, and a certain fast Fourier transform (FFT) algorithm [8], [9], [10].
Unfortunately, to our knowledge, all existing factor-graph-capable frameworks are developed to run on standard personal computers (PCs) [11], [12]. This, in turn, will conceal the generality of factor graphs. To extend the applicability of factor graphs and to provide practical tools for real technical system applications such as in robotics, we propose an implementation of belief propagation engine for factor graphs on dedicated hardware. Such hardware will provide a convenient way to harness parallelism to achieve high performance computation in low power mode, which is a very important factor that determines the successful operation of many robotic platforms.
In this paper, we focused on the exploration and development of a system that works best with exact inference in a discrete form of factor graphs. We are also aware of the trade-off between fidelity and granularity, usually expressed as a cost function, that rises naturally almost in every digital machine involving discrete-event systems and that there is no single optimal solution that can be applied for every situation [13], [14].
For the demonstration purpose, we use the Zynq-7020 from Xilinx as our system-on-chip (SoC) platform, which is internally composed of two tightly coupled sub-systems: the PS (processing system, i.e., microprocessor core) and the PL (programmable logic, i.e., FPGA fabric). The PS sub-system consists of two ARM Cortex-9 processors and the PL sub-system is equivalent to the FPGA Artix-7 from Xilinx. This SoC offers flexibilities because of the fact that their FPGA resources can be structured and organized to mimic the true parallelism in complex computations. This attribute is very useful for performing intense multiplication operations in a factor graph. We can effectively distribute the computation into concurrent calculations in every slice of the FPGA in the SoC device. We refer to our factor graph framework on an SoC as an “embedded factor graph”. To our knowledge, it is still uncommon to see a factor graph in any embedded systems.
The novelty of this work is the exploration of the implementation of probabilistic inference using message-passing-based methods for factor graphs natively in low-level hardware. Such fundamental probabilistic inference hardware, which takes into account the uncertainty and randomness into its computational platform, will produce more powerful, flexible and efficient building blocks for a more complex computational intelligence machine. In summary, the major contributions presented in this paper are as follows:
1.Implementation of belief propagation for SoC-based factor graphs that integrates both software-based control and real-time hardware-based processing.2.Introduction to a reconfigurable computing framework for general PGMs. The factor graph’s core modules in the FPGA part are implemented as IPs that can be re-configured to accommodate various requirements for research on PGMs.3.Our design readily accommodates the requirements to support technical systems with PGM-based cognitive capabilities.
This paper is organized as follows. After providing selected reviews on existing factor graph implementations in Section 2, we describe our development paradigm in Section 3. The paradigm provides guidance on the development of our proposed embedded framework, which is explained in detail in Section 4. In Section 5, we provide an analysis of the implementation results. A thorough discussion about the overall evaluation of our proposed methods is presented in Section 6. Finally, we conclude our work and propose recommendations for future work.
