This introductory section is divided into three parts: we begin by motivating our work, continue by discussing the problems that we study, and finally briefly present our results.
1.1. MotivationThe constraint satisfaction problem over a constraint language Γ (CSP(Γ)) is the problem of finding a variable assignment which satisfies a set of constraints, where each constraint is constructed from a relation in Γ. This problem is a widely studied computational problem and it can be used to model many classical problems such as k-coloring and the Boolean satisfiability problem, in a natural and uniform way. In the context of artificial intelligence, CSPs have been used for formalizing a wide range of problems, cf. Rossi et al. [55]. Efficient algorithms for CSP problems are hence of great practical interest. If the domain D is finite, then a CSP(Γ) instance I with variable set V can be solved in O(|D||V|⋅poly(‖I‖)) time by enumerating all possible assignments. Hence, we have an obvious upper bound on the time complexity. This bound can, in many cases, be improved if additional information about Γ is known, cf. the survey by Woeginger [65] or the textbook by Gaspers [29]. There is also a growing body of literature concerning lower bounds [34], [39], [42], [61].When it comes to CSPs over infinite domains, there is a large number of results that identify polynomial-time solvable cases, cf. Ligozat [45] or Rossi et al. [55]. However, almost nothing is known about the time complexity of solving NP-hard CSP problems. One may conjecture that a large number of practically relevant CSP problems do not fall into the tractable cases, and this motivates a closer study of the time complexity of hard problems. Thus, we initiate such a study in this article.
1.2. Computational problemsAssume that we are given an instance of CSP(Γ) where Γ is a constraint language over an infinite domain. Which upper bounds can we provide for CSP(Γ)? Clearly, the method for finite-domain CSPs, based on enumerating all possible variable assignments, no longer work since the domain is infinite. In fact, infinite-domain CSPs are in general undecidable [7]. A first step is therefore to only consider decidable infinite-domain CSPs. However, even for such problems, for every recursive function, one can find a decidable CSP problem which cannot be solved faster than this [4]. Hence, we first need to fix a class of constraint languages X such that CSP(Γ) is included in a reasonable complexity class for every Γ∈X. Througout this article we exclusively study the case when CSP(Γ) is included in NP, since this is a natural and well-studied class of problems. However, when considering CSPs over infinite domains, representational issues also become highly important. A relation in a finite-domain CSP problem is easy to represent by simply listing the allowed tuples. When considering infinite-domain CSPs, the relations need to be implicitly represented. A natural way is to consider disjunctive formulas over a finite set of basic relations. Let B denote some finite set of basic relations such that CSP(B) is tractable. Let B∨ω denote the closure of B under finitary disjunctions, and let B∨k be the subset of B∨ω containing only disjunctions of length at most k. We first consider a finite-domain example for illustrative purposes: let D={true,false} and let B={B1,B2} where B1={true} and B2={false}. In other words a unary constraint of the form B1(x) forces the variable x to be mapped to true, and B2(y) forces the variable y to be mapped to false. It is then easy to see that CSP(B∨ω) corresponds to the Boolean SAT problem while CSP(B∨k) corresponds to the k-SAT problem. Early examples of disjunctive constraints over infinite-domains can be found in, for instance, temporal reasoning [43], [37], [58], reasoning about action and change [26], and deductive databases [41]. More recent examples include interactive graphics [48], rule-based reasoning [46], and set constraints (with applications in descriptive logics) [10]. There are also works studying disjunctive constraints from a general point of view [16], [21] but they are only concerned with the separation of polynomial cases from NP-hard cases, and do not further investigate the time complexity of the hard cases.There is also an important connection to constraint languages containing first-order definable relations (see Section 2.2 for details). Assume Γ is a finite constraint language containing relations that are first-order definable in B, and that the first order theory of B admits quantifier elimination. Then, upper bounds on CSP(Γ) can be inferred from results such as those that will be presented in Sections 3 and 4. This indicates that studying the time complexity of CSP(B∨ω) is worthwhile, especially since our understanding of first-order definable constraint languages is rapidly increasing [8].CSPs in certain AI applications are often based on binary basic relations and unions of them (instead of free disjunctive formulas). This is the predominant way of representing constraints in, for instance, spatial reasoning. Clearly, such relations are a subset of the relations in B∨k and we let B∨= denote this set of relations. We do not explicitly bound the length of disjunctions since they are bounded by |B|. The literature on such CSPs is voluminous and we refer the reader to Renz and Nebel [54] for an introduction. We remark that there exists examples of undecidable CSP problems over constraint languages of the form B∨= [32]. Hence, even for such restricted problems it is impossible to give general upper bounds, unless additional restrictions are imposed on the set B of basic relations.
1.3. Our resultsThroughout the article, we primarily measure time complexity in the number of variables. Historically, this has been the most common way of measuring time complexity: the vast majority of work concerning finite-domain CSPs concentrates on the number of variables. One reason for this is that an instance may be massively larger than the number of variables — a SAT instance I=(V,C) (where V is the set of variables and C is the set of clauses) may contain up to 22|V| distinct clauses if repeated literals are disallowed — and measuring in the instance size may give far too optimistic figures. This may be quite detrimental since naturally appearing test examples tend to contain a moderate number of constraints. In light of this, it is much more informative to know that SAT can be solved in O(2|V|⋅poly(‖I‖)) time (where ‖I‖ denotes the total number of bits needed for representing I) instead of merely knowing that it is solvable in O(2‖I‖⋅poly(‖I‖)) time (which of course is true since |V|≤‖I‖). For instance, we immediately conclude from the bound O(2|V|⋅poly(‖I‖)) that increasing the number of variables increases the run time much more rapidly than increasing the number of clauses. This is something that one cannot immediately infer from the bound O(2‖I‖⋅poly(‖I‖)).Let us now turn to the time complexity of solving infinite-domain CSPs. To solve such problems in practice, backtracking algorithms are usually employed. The literature on heuristically guided backtracking algorithm and empirical analyses of such algorithms is huge: we refer the reader to any good textbook (such as Dechter [24] or the handbook edited by Rossi et al. [55]) on constraint satisfaction for more information about this. What we find lacking in the literature are analyses of the asymptotical performance of such algorithms, i.e. their worst-case behavior. Unfortunately, we show in Section 3 that they can be highly inefficient in the worst case. Let p denote the maximum arity of the relations in the set of basic relations B, let m=|B|, and let |V| denote the number of variables in a given CSP instance. We show (in Section 3.1) that the time complexity ranges from O(22m⋅|V|p⋅log⁡(m⋅|V|p)⋅poly(‖I‖)) (which is doubly exponential with respect to the number of variables) for CSP(B∨ω) to O(22m⋅|V|p⋅log⁡m⋅poly(‖I‖)) time for B∨= (and the markedly better bound of O(2|V|plog⁡m⋅poly(‖I‖)) if B consists of pairwise disjoint relations). The use of heuristics can probably improve these figures in some cases, but we have not been able to find such results in the literature and it is not obvious how to analyze backtracking combined with heuristics. At this stage, we are mostly interested in obtaining a baseline: we need to know the performance of simple algorithms before we start studying more sophisticated ones. However, some of these bounds can be improved by utilizing standard methods described in the literature: we demonstrate this in Section 3.2 by applying the highly influential sparsification method by Impagliazzo, Paturi, and Zane [36].In Section 4 we switch strategy and show that disjunctive CSP problems can be solved significantly more efficiently via enumerative methods. By an enumerative method, we mean a method that is based on enumerating some kind of objects that can be used for determining whether the given instance has a solution or not. Let us for a moment go back to the simplest possible method for solving CSPs over a finite domain D: enumerate all assignments of values from D to the variable set V. This process yields a (very simple) algorithm running in O(|D||V|⋅poly(‖I‖)) time. This is the archetypical example of an enumerative method. However, it is not directly applicable to infinite-domain CSPs due to the size of the set D.We introduce two enumerative methods in this article: structure enumeration and domain enumeration. Structure enumeration is inspired by model checking for finite structure: we enumerate a sequence of structures (which themselves are small CSP instances) and check whether the given instance is satisfied by the (implicitly represented) solutions of the structures. Domain enumeration is more closely related to the enumerative approach to finite-domain CSPs. In certain cases, one can identify finite sets of ‘canonical’ domain elements with the following property: there exists a solution if and only if there is a solution that only uses the canonical elements. There are several important differences between these two methods but there is a general rule of thumb: structure enumeration is typically easier to apply and it has a greater range of applicability but it gives worse complexity figures than domain enumeration.By using structure enumeration, we obtain the upper bound O(2|V|p⋅m⋅poly(‖I‖)) for CSP(B∨ω). If we additionally assume that B is jointly exhaustive and pairwise disjoint then the running time is improved further to O(2|V|p⋅log⁡m⋅poly(‖I‖)). This bound beats or equals every bound presented in Section 3. We then proceed to show even better bounds for certain choices of B by using domain enumeration. For instance, we consider certain temporal CSPs.In the last part of the article (Section 5), we consider the problem of determining lower bounds for CSP(B∨ω), i.e. identifying functions f such that no algorithm for CSP(B∨ω) has a better running time than O(f(|V|)). We accomplish this by relating CSP problems and certain complexity-theoretical conjectures, and obtain strong lower bounds for the majority of the problems considered in Section 4. As an example, we show that the temporal CSP({<,>,=}∨ω) problem, where <,> and = are the order relations on Q, is solvable in time O(2|V|log⁡|V|⋅poly(‖I‖)) but, assuming a conjecture known as the strong exponential time hypothesis (SETH), not solvable in O(c|V|) time for any c>1. Hence, even though the algorithms we present are rather straightforward, there is, in many cases, very little room for improvement, unless the SETH fails. It appears much more difficult to obtain lower bounds for problems of the type CSP(B∨=). However, we succeed in giving the lower bound O((2)|V|) for Allen's interval algebra. This bound is not based on the (strong) exponential time hypothesis but on bounds on computing the chromatic number of graphs. The upper bound for Allen's algebra is O(22|V|⋅(1+log⁡|V|)) so there is plenty of room for improvements in this case.This article is a revised and extend version of an earlier conference publication [38].
