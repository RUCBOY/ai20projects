General-purpose sorting algorithms are based on comparing and exchanging pairs of inputs. If the order of these comparisons is predetermined by the number of inputs to sort and does not depend on their concrete values, then the algorithm is said to be data oblivious. Such algorithms are well-suited for e.g. parallel sorting or secure multi-party computations, unlike standard sorting algorithms, such as QuickSort, MergeSort or HeapSort, where the order of comparisons performed depends on the input data.
Sorting networks are a classical formal model for data-oblivious algorithms [19], where n inputs are fed into networks of n channels connected pairwise by comparators. Each comparator takes the two inputs from its two channels, compares them, and outputs them sorted back to the same two channels. A set of consecutive comparators can be viewed as a “parallel layer” if no two comparators act on the same channel. A comparator network is a sorting network if the output on the n channels is always the sorted sequence of the inputs.
Ever since sorting networks were introduced, there has been a quest to find optimal sorting networks: optimal size (minimal number of comparators), as well as optimal depth (minimal number of layers) networks. In their celebrated result, Ajtai, Komlós and Szemerédi [1] give a construction for sorting networks with O(nlog⁡n) comparators in O(log⁡n) parallel levels. These AKS sorting networks are a classical example of an algorithm optimal in theory, but highly inefficient in practice. Although they attain the theoretically optimal O(nlog⁡n) number of comparisons and O(log⁡n) depth, the AKS networks are infamous for the large constants hidden in the big-O notation. On the other hand, already in 1968, Batcher [4] gave a simple recursive construction that, even though it creates networks of depth O(log2⁡n), is superior to AKS networks for all practical values of n.
It is of particular interest to construct optimal sorting networks (both in size and in depth) for specific small numbers of inputs. Such networks can be used as building blocks to construct more efficient networks on larger numbers of inputs, for example by serving as base cases in recursive constructions such as Batcher's odd-even construction.
Already in the fifties and sixties various constructions appeared for small sorting networks on few inputs. In the 1973 edition of “The Art of Computer Programming” [19] (vol. 3, Section 5.3.4), Knuth detailed the smallest sorting networks known at the time with n≤16 inputs.
However, showing their optimality has proved to be extremely challenging. For n≤8 inputs, optimality was established by Knuth and Floyd [16] in 1973. No further progress had been made on the problem until 1989, when Parberry [28], [29] showed that the networks given for n=9 and n=10 are also optimal. Parberry obtained this result by implementing an exhaustive search with pruning based on symmetries in the first two parallel steps in the sorting networks, and executing the algorithm on a Cray-2 supercomputer. Despite the great increase in available computational power in the two and a half decades since, his algorithm would still not be able to handle the case n=11 or bigger. More recently, there were additional attempts [27] at solving the n=11 case, but we are not aware of any successful one.
In this paper, some 40 years after the publication of the networks by Knuth, we finally prove their optimality by settling the remaining open cases of 11≤n≤16 inputs. Our approach combines two methodologies: symmetry breaking and Boolean satisfiability.
Symmetry Breaking.We show how to construct a small set Rn of two-layer networks on n channels such that: if there is a sorting network on n channels of a given depth, then there is one whose first two layers are in this set. We first show how each two-layer network can be represented by a graph, with isomorphic graphs corresponding to equivalent networks. By defining a notion of “relative strength” between networks that takes into account their effects on the inputs, we further restrict the set of two-layer networks. We show how to characterize the strongest networks using context-free grammars, which enables us to construct the sets Rn for up to n=40 inputs within two hours of computation. For example, R11 consists of 28 networks, enabling us to solve the optimal-depth problem for n=11 in terms of only 28 independent cases, as opposed to over one billion cases of all two-layer networks on 11 channels. Similarly, we show that |R13|=117.Boolean Satisfiability.With the first two layers restricted to a small set, we construct a family of propositional formulas whose satisfiability is necessary for the existence of sorting networks of a given size. Using an off-the-shelf SAT solver we show that all the constructed formulas are unsatisfiable, and hence we conclude that for n≤16 inputs the networks listed in [19] are indeed optimal. A similar construction, without restricting the first two layers, is able to find optimal-depth sorting networks for n≤10 inputs and prove them optimal, thus providing independent confirmation of the previously known results.
We obtained all our results using an off-the-shelf SAT solver running under Linux on commodity hardware. It is noteworthy that our algorithm required a few seconds to prove the optimality of networks with n≤10 inputs, whereas for n=10 the algorithm described in [28] was estimated to take hundreds of hours on a supercomputer, and the algorithm described in [27] took more than three weeks on a desktop computer.
The work we describe is another success in the history of computer-assisted proofs. Since the proof of the four-color theorem [2], [3], in 1976, several mathematical results have been proven with the help of a computer. Nearly all of these have only been proved by exhaustively analyzing an extremely large search space and using clever reduction techniques, as in our case. SAT-solving has been a key tool in some recent successes in this area, such as the proof of Erdős' discrepancy conjecture for C=2 [20], the proof that the Ramsey number R(3,3,4) is equal to 30 [14], and the solution to the Boolean Pythagorean Triples Problem [18].
This paper is an extended version of [5] and [12]. The first paper presents the theory and experiments for calculating optimal sorting networks. In the current paper we construct even smaller sets of “non-isomorphic” two-layer networks using a much faster algorithm (the construction in [5] does not scale beyond n=13 inputs). This new algorithm is a culmination of the work presented in the second paper [12]. However, that paper deals only with computing the sets of “relevant” two-layer networks, and not with computing the optimal sorting networks as we do in this paper.
