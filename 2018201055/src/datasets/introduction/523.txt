The identification and study of common computational patterns is an important way to produce software that is systematically efficient on a variety of similar applications and on different target architectures. By focusing on these patterns, we give names to solutions to recurring problems that experts in a problem domain gradually learn and take for granted.
Agent-based simulations (ABS) [1] represents a way to model, through a population of agents, the dynamics of complex phenomena. Such agents follow a few simple principles: they may be of different types (heterogeneous), move in an explicit space such as an multi-dimensional grid, only interact with close agents (locality), and there is no central control over them (autonomous). Emergent behaviors from ABS usually result in computational patterns.
Historically, ABS computational models have been used to model and understand the society by translating social dynamics into computation. Examples are voting behaviors [2], epidemics [3], stock markets [4] and spatial unemployment patterns [5]. Applications go far beyond social sciences, however: the predator–prey equilibrium investigated by ecologists [6]; hazard prevention in evacuation scenarios [7]; keratinocyte colony formation modeled by cellular biologists [8]; the complex behaviors of cooperation simulated by ecologists [6]; crowd simulation interactions in virtual scenes [9] are all notable examples of ABS applications.
All of these ABS applications are characterized by the fact that they require a significant amount of computational power as both a larger number of agents is required to accurately model large populations and, at the same time, models are getting more sophisticated, with complex interactions and strong behavior differentiation between agents in the same simulation, i.e., increasing heterogeneity.
These two aspects have motivated scientists to develop parallel and distributed ABS implementations targeting very different platforms such as Graphics Processing Units (GPUs) [10], High Performance Computing (HPC) clusters [11], and cloud computing systems [12]. Each implementation focuses on a specific agent domain and on platform-specific parallelization methods. Notwithstanding the fact that the core concepts of existing ABS libraries are basically the same, the diversity of both target hardware platforms and application domains has led to very different software infrastructures. Unfortunately, this also led to simulation environments whose comparison and replication is hard to perform.
As a consequence, scientists using ABS face four major challenges:

•Performance: The increasing model complexity and the growing number of agents demand for higher computational power, with parallel and distributed implementations, and for efficient algorithms for local agents query. Both are necessary to simulate modern large and complex ABS.•Programmability: Scientists and domain experts often have little expertise on HPC programming; thus, they need high-level tools and programming environments where only domain knowledge is required.•Portability: Existing approaches for writing ABS simulation spans different tool and implementations. Agent simulations should be written in a programming environment that makes it possible to target a variety of parallel and distributed systems without any program changes.•Reproducibility: Simulations must be easy to reproduce, returning similar results even if obtained by different implementations and platforms.
In the pursuit of finding a solution to all of these issues, scientists from different fields have joined their forces into the community-driven project OpenAB [13], which provides procedures, data and models for the benchmarking of agent-based simulations on parallel and distributed computing systems. This article gives a complete introduction of OpenABL [14], the domain-specific language (DSL) developed by and for the OpenAB community to tackle the four major challenges raised above, and provides an exhaustive evaluation of the OpenABL compiler implementation on complex simulations and several parallel target platforms.
The rest of this article is organized as follows. Section 2 introduces the OpenABL language, a domain-specific and high-level language that allows scientists to write complex agent models with few lines of code and no knowledge about the target platform. The language is designed to easily define space and locality properties of a simulation, and supports advanced features such as heterogeneous agent types and the dynamic creation and removal of agents. Two cornerstones of the language are the step function, which implicitly enable agent parallelism, and the near query, which is the base for local agent query. In this article, each language semantic is discussed in detail, with code excerpt taken from a complex application scenario. predator–prey. Additionally, two new language semantics are introduced: sequential step functions and reductions.
A source-to-source compilation infrastructure implements the OpenABL language and maps language semantics such as agent, step function and near query, into a high-level intermediate representation. Thus, a code generation infrastructure based on pluggable backends is capable to efficiently translate those semantics and generate high-performance parallel code targeting a broad range of systems, from multi-core CPUs and GPUs to cloud systems. Section 3 describes in details the parsing, the intermediate representation, the parallel mapping and the limitations of the source-to-source compilation infrastructure.
An extended experimental evaluation is presented in Section 4. We have evaluated the performance of the code generated by the OpenABL compiler on seven applications. In particular, we used two complex applications with both heterogeneous agent types and dynamic agent addition/removal as a test benchmark: predator–prey, an animal ecology simulation where a set of predators hunt for preys; and keratinocyte, a biological simulation that explores the self-organization of normal human keratinocytes (NHK) and how the cell–cell and cell–substrate adhesions are critically important to NHK self-organization.
Finally, this article presents a discussion of related work (Section 5) and concluding remarks (Section 6).
