There are several automatic methods for generating test data, each with its own advantages and disadvantages[1]. Some of the well-known methods are random testing, symbolic execution, and search-based testing. Random test data generation is easy to implement and fast, but its disadvantage is poor code coverage[2], [3], [4]. In the symbolic execution methods, the program is executed with symbolic (instead of actual) input values. In the next step, test data are generated by solving constraints obtained from the symbolic execution of program paths. Some of the main challenges of this method are path explosion, difficulty in handling loops, and solving complex constraints[5].
Search-based test data generation methods[6] use metaheuristic optimization techniques, which attempt to find appropriate test data from the input domain of the program under test (PUT), in order to satisfy the specified test goals (such as covering all program branches). Search-based methods leverage approaches like evolutionary algorithms (e.g.,genetic algorithm[7]), swarm intelligence algorithms (e.g.,ant colony optimization[8] and particle swarm optimization[9]), and simulated annealing[10] to search in the program input domain.
Conventional search-based test data generation algorithms search in the space of program input values. For example, consider the following method (circled numbers show branch numbers):  Download : Download high-res image (121KB)Download : Download full-size image

Finding instances of (x,y,z) satisfying the condition for covering branch (2,T) (meaning the true branch of branch number 2), in a space of 32 bit integers, has a probability of 232296=1264, which is too small. This research proposes that a search be conducted in the space of constraints over program parameters, instead of directly searching for program input values. Constraints are constructed, mutated and combined in a black box manner, and test data are generated by solving these constructed constraints. Our hypothesis is that searching in the space of constraints over program parameters dramatically improves the efficiency and effectiveness of the search-based test data generation algorithms, and leads to faster and more targeted searches.
Constraints specify relationships between some variables, and restrict possible values that those variables can take. Program input values are solutions to an underlying (original) path constraint over program input variables which determine the path the program takes. For program g, typical search algorithms try to find instances of solutions to the original path constraint x=y∧y=z.
The main idea in this paper is to generate test data by evolving a population of constraints on program input parameters and solving those constraints. The proposed method regards the operations and comparisons performed on program parameters as black boxes. The constraints of the population are merely changed based on evolutionary operations on those constraints, and by evaluating the effects of these modifications on the coverage of program branches.
In comparison to the symbolic execution methods, the proposed method has the advantage of constructing approximate constraints. The symbolic execution methods record every operation and comparison performed on input symbolic parameters and construct the path constraint based on those operations and comparisons. It may be possible that the actual operations performed on program parameters lead to constructing constraints that are too difficult for a constraint solver. Finding an easier, close enough approximation of the original constraint seems to be a good solution to this problem. The proposed method constructs constraints by a completely different approach (a black-box search over constraints and mutating and combining them). This search may lead to constructing constraints which have the same solution as the underlying constraints, but are not exactly the same constraints.
The proposed method is based on a process of evolution of constraints. In other words, we construct constraints from simple predicates (such as x=y, x<y, or x=1), and make changes to them so that we acquire more accurate (and likely more complex) constraints related to the original constraints of the PUT. This study employs the technique of genetic programming (GP)[11] for learning constraints required to cover program parts. GP is a technique to generate computer programs using an evolutionary algorithm such as genetic algorithm. GP evolves a population of computer programs to generate programs which satisfy a criterion.
The proposed method uses a special form of computer program as its individuals. An individual of the method is a constraint formed by the conjunction or disjunction (or the negation of conjunction or disjunction) of predicates over program input parameters. This constraint can be represented by an abstract syntax tree (AST). A solution to one of these constraints is an input for the PUT. The goal is to discover constraints which their solutions cover program branches if taken as the input to the PUT.
As a simple example, consider the trivial Java method in Fig.1 (For a more complete example refer to Section3.2). This program is hard for both search-based and symbolic execution methods to fully cover all of the branches of this program. In case of conventional search-based methods, it is hard because the solution space of the constraint constructed from the condition for branch (1,T) (i.e.,the true branch of the if statement) is too narrow. For the symbolic execution method, the source of difficulty is that solving constraints 2x+1=y and 2x+1≠y is hard for constraint solvers.
For this program, the proposed algorithm works as follows: At first, a set of ASTs for random simple constraints such as {x=0,y=0,x=1,x=y,x>y,…} is generated. The proposed method utilizes GP operators (mutation and crossover) to continuously increase the complexity and accuracy of constraints, guided by metrics such as branch distance (see Section2.1.3). As a result, a set of constraints such as {x+2=y∧x=0,x>y∧y≥1,…} are constructed. The solutions for these approximate and simplified constraints, e.g.,(x,y)=(0,2) for x+2=y∧x=0 and (x,y)=(2,1) for x>y∧y≥1 suffices to cover all branches of this program. If the stronger constraint x=0 holds, then 2x+1=x+1 is satisfied as well, and the solution of this constraint is enough to cover the true branch (i.e.,(1,T)). If x>y≥1 then 2x+1>y, and thus, finding any instance of (x,y) where y≥1∧x>y is sufficient to cover the false branch (i.e.,(1,F)). We see that we do not really have to solve the real underlying constraint. We can hope to find approximate and easy to solve constraints, which for our purpose are as good as the real ones. This is done by performing a bit of search over random constraints on input parameters. The search is carried out by changing and combining the constraints, and is guided by an appropriate fitness function.
Currently, our implementation of the proposed approach only constructs and solves constraints for numeric and boolean input parameters. However, when combined with EvoSuite[12], [13], [14], as it is done in Section3.3, we are able to use the proposed method for classes with methods having other types of input parameters, as well. Thus, EvoSuite will handle the parameter types which are unsupported by the proposed method.Download : Download high-res image (117KB)Download : Download full-size imageFig. 1. An example Java method. The circled number shows the branch number.
Our previous work[15] also makes use of constraint solving to help search-based test data generation. The idea in that paper is to employ likely invariants to learn valid constraints for each branch of the PUT, and generating test data similar to the inputs with the highest fitness, using these constraints. The main difference between the current work and[15] is that, the former uses GP to directly construct and evolve constraints, without checking the validity of constraints for each covered branch, for every new input data.
In summary, the main contribution of this paper is proposing a test data generation method using GP. We also show how we can integrate the proposed method with tool EvoSuite. The proposed approach has been experimented on a number of Java benchmark programs. The results show tangible improvements in terms of both efficiency and effectiveness.
The remainder of this paper is organized as follows. Section2 gives an overview of the concepts used in this research, and the related works. Section3 explains the proposed method. Section4 analyzes the proposed method. In Section5, experimental results are given. Section6 discusses the threats to the validity of this work. Section7 includes conclusions and some directions for future work.
