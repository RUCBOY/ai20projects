It is estimated by IDC [19], by the year 2020, the data held by each person would reach 5200 GB. It’s difficult for individual users to store such large-scale data locally. Thus, more and more users utilize the cloud storage service owing to the cloud’s massive storage capacity and computational power. However, 75% of the cloud data are duplicated according to a survey from EMC [10]. Storing one single copy of the duplicated files is a better choice for reducing the storage overhead of the cloud [1]. As a result, the deduplication technique has drawn significant attention of researchers.
Cloud data auditing with deduplication technique can check whether the user’s data is intact, and reduce the storage cost of the cloud. For each data block, the user utilizes his/her own secret key to compute an authenticator. This authenticator is used for data integrity verification. Different users will generate different authenticators for the same data block because they hold different secret keys. As a result, this approach cannot achieve authenticator deduplication. In reality, authenticators occupy considerable storage space in the cloud. If the security parameter is set as 80bits, one data block will occupy 20bytes storage space, whereas one authenticator will occupy up to 64bytes storage space [20]. Therefore, deduplicating the file and the authenticator at the same time is an important issue in the cloud data auditing systems.
Using message-locked key (the file’s hash value) as the secret key to compute authenticators can achieve authenticator deduplication [12]. However, it brings new problems. The linkage between the data and its owner is broken. And the large-scale of users’ cloud files bring a huge key management burden. Besides, some files have low entropy, e.g., electronic medical records and sensor data from IoT devices. Once the malicious cloud correctly deduces the content (or hash) of the file, it can deduce the message-locked key. As a result, the malicious cloud could forge the authenticators and make the cloud data auditing unable to function anymore.
To solve these issues, recently, Liu et al. [20] have proposed One-tag Checker, a cloud data auditing scheme with file and authenticator deduplication. They claim that their scheme is secure under the condition that the cloud can somehow know the content (or hash) of the file. Unfortunately, once the malicious cloud correctly deduces the hash of the file, it actually can forge the corresponding authenticators in this scheme, which contradicts with their security definition [20]. We will give the attack strategy in the APPENDIX. Besides, in their scheme, users have to be always online and interact with the Third Party Auditor (TPA) during each auditing process. Obviously, this approach is infeasible in real-world applications.
Contribution:
In this paper, we propose a novel cloud data auditing scheme with file and authenticator deduplication. For a group of users who own the same file, only one copy of the data block and authenticator is stored in the cloud. To the best of our knowledge, the proposed scheme is the first practical one that truly achieves low-entropy security. For the low-entropy file, the cloud cannot forge any authenticator to pass the auditing verification. In addition, the proposed scheme is user-friendly. Users do not need to keep interacting with the TPA during each auditing task. As a result, users are relieved from the tedious auditing task.
In the proposed scheme, we give a new method to compute the authenticator and design a new form of the file tag. The authenticator guarantees low-entropy security, since it is generated by the randomize-message-locked key. The new form of the file tag links the file and its owner. It also allows the TPA to perform the auditing task without always interacting with the user.
We give rigorous security analysis, showing that the proposed scheme satisfies soundness and low-entropy security. We also give detailed experiments to show the efficiency of our scheme.
Organization: The organization of this paper is demonstrated as follows. In Section 2, we introduce the preliminaries. In Section 3, we show our system model, definition and design goals. In Section 4, the scheme’s detail is shown. In Section 5, we show the correctness and the security proof of the proposed scheme. In Section 6, we give the comparison and the experiment results. In Section 7, we introduce the related work. In Section 8, we give the conclusion.
