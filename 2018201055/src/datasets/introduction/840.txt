The branch-and-bound (B&B ) algorithm (Land and Doig, 1960) has been widely-used for solving optimization problems exactly (without loss of generality, we assume the optimization problem is a minimization problem). The algorithm builds a search tree of nodes that represent regions of the solution space. Each node can be explored to either find the best solution in the corresponding solution space or generate child nodes that further divide the solution space. Moreover, the algorithm can detect regions of the solution space that do not lead to an optimal solution. These regions can then be pruned (i.e., removed from further consideration). We say that a node is processed if it is either explored or pruned without exploration. When all nodes are processed, the algorithm either terminates with an optimal solution or concludes that the problem is infeasible.
The procedure used by a B&B algorithm to determine the order in which nodes in a search tree are processed is called a search strategy. Three strategies (and their variations) have been frequently used: Depth First Search (DFS), Breadth First Search (BrFS) and Best First Search (BFS). DFS selects unprocessed nodes to be processed in the reverse order that they are generated (Tarjan, 1972). BrFS selects unprocessed nodes following the order that they are generated. BFS stores all unprocessed nodes and tries to identify the node that is the most likely to lead to an optimal solution. This is achieved by applying a measure-of-best function μ to the unprocessed nodes and selecting the node with the minimum value of μ. A frequently used function for minimization problems is μLB, which returns a lower bound on the value of the feasible solutions that can be found within the subtree rooted at a node. In this work, if not specified otherwise, we assume BFS uses μLB. Regardless of the measure-of-best function, BFS requires exponential memory with respect to the depth of the search tree to store all the unprocessed nodes in the worst case. Dechter and Pearl (1985) shows that under some assumptions (notably no ties in the measure-of-best function), BFS explores the smallest number of nodes of any search strategy.
On Mixed Integer Programming (MIP) problems, a hybrid search strategy of BFS and DFS (BFS with diving) has been shown to be the most effective for a general purpose solver (Achterberg, 2007, Linderoth and Savelsbergh, 1999). In its basic form, BFS with diving uses DFS for the search until some criteria are met, and the search strategy selects a new node using BFS, from which node DFS is used again. Solving child node immediately after its parent node means the solver can use the solution information from the parent node for solving the child node, which reduces the solving time of the child node. This advantage is called a “warm start” (Achterberg, 2007). This search strategy is the basis for the search strategies used by both commercial and non-commercial MIP solvers today (e.g., CPLEX, SCIP (Achterberg and Wunderling, 2013, Achterberg, 2007)).
On combinatorial optimization problems, where there is no general purpose solver and a complete B&B algorithm has to be created, the choice of the search strategy is decided by the authors. The “warm start” that makes BFS with diving effective in MIP problems may not be available on these problems. As a result, when there is no special structure of the search tree that can be utilized by DFS or BrFS and no severe space constraint, BFS is frequently chosen since it tends to explore fewer nodes than DFS and BrFS (Balas et al., 1995, Coutinho et al., 2016).
In recent years, we have developed a new search strategy called Cyclic Best First Search (CBFS). The search strategy has been applied to many optimization problems, including scheduling (Kao et al., 2009, Sewell and Jacobson, 2012, Sewell et al., 2012, Morrison et al., 2014, Zhang et al., 2018), graph coloring (Morrison et al., 2016a), and MIP problems (Morrison et al., 2017) (notably, we showed that the BFS with diving strategy can be represented as a CBFS strategy). The CBFS strategy partitions a search tree by assigning unprocessed nodes to contours using a labeling function κ, where each contour is a set of unprocessed nodes. Then, at each iteration of the B&B algorithm, the search strategy applies a measure-of-best function μ to a contour for node selection. Different assignments of nodes to contours can lead to significantly different search orders. One variation of CBFS that has been shown to outperform BFS in several combinatorial optimization problems (Kao et al., 2009, Sewell and Jacobson, 2012, Sewell et al., 2012, Morrison et al., 2014, Zhang et al., 2018) is CBFS-depth, which partitions unprocessed nodes into contours by their depth levels in the search tree.
We have observed that by applying CBFS-depth to certain B&B algorithms, the number of nodes explored to prove optimality is smaller than that of BFS on some problems. In fact, in the B&B algorithms proposed using CBFS-depth (Kao et al., 2009, Sewell and Jacobson, 2012, Sewell et al., 2012, Morrison et al., 2014, Zhang et al., 2018), the number of nodes explored to prove optimality is frequently smaller than that of BFS.
On the other hand, CBFS-depth is known to explore no fewer nodes than BFS on some other problems (Morrison et al., 2016a, Morrison et al., 2017). To keep the analysis independent of specific problems, we will use the number of nodes explored to prove optimality as the performance metric of the search strategies. The reasons for the variation in the performance of CBFS-depth in comparison to BFS on different problems have not been studied further. In this work, our goal is to investigate the performance variation by looking into the characteristics of a search tree (not specific to any particular problem) that can lead to CBFS-depth exploring fewer nodes than BFS to prove optimality.
The study of the performance of search strategies in terms of the number of nodes explored has been done for DFS and BFS. Vempaty et al. (1991) studies the time and space complexity of search strategies including BFS and DFS on a tree model where nodes with the same costs are in the same depth level. The cost of a node can be considered as a lower bound used as μLB by BFS and the solution value if the node is a solution. As a result, once a solution is found, only nodes in smaller depth levels have to be explored. Each node in the same depth level is assumed to have the same probability (referred to as solution density) of being a solution. Given a factor on the number of child nodes that can be generated from a parent node, as well as the solution densities (probabilities of the nodes containing the optimal solution), the authors discuss the expected number of nodes to be explored by different search strategies. Zhang and Korf (1995) proposes a random search tree model with random non-negative edge costs (the cost of a node is the sum of the costs of edges on the path to reach the node) and variable branching factor to study the expected number of nodes to be explored to prove optimality of the two search strategies. More recently, studies on search strategies have focused on computational experiments (Linderoth and Savelsbergh, 1999, Achterberg, 2007). Additionally, Bourgeois et al. (abs/1505.04969, 2015.) studies the average-case performance of BFS on a maximum independent set problem.
In terms of CBFS-depth, Morrison et al. (2017) shows that, in terms of the number of nodes explored, the worst-case performance of CBFS-depth is significantly worse than that of BFS. Despite the worst-case performance, the authors hypothesize that the reason why the CBFS-depth strategy explores fewer nodes than BFS on some problems is that, by grouping nodes into different contours, CBFS-depth can distinguish nodes with the same μ value which are indistinguishable by BFS. However, Morrison et al. (2017) does not investigate this matter further or identify conditions under which CBFS-depth will perform better than BFS from either a theoretical or experimental perspective. In this work, we seek to answer the following question: if the assumption of the absence of ties in the measure-of-best function is not met, and BFS cannot be proven to explore the minimum number of nodes of any search strategy, then under what conditions on the measure-of-best function values will CBFS-depth explore fewer nodes than BFS?.
To facilitate the investigation, we first propose a search tree model that allows control over the distribution of nodes with different measure-of-best function values within the tree. Using this model, the average-case performance (the expected number of nodes explored to prove optimality) is measured across these search trees. The observations based on the results from the search tree model are then tested on existing optimization problems.
Let B&B-CD denote a B&B algorithm with the CBFS-depth strategy and B&B-BFS denote a B&B algorithm with the BFS strategy, and let the measure-of-best function return a lower bound for each node. First, we present assumptions of the B&B algorithm and the search tree model that are necessary for our analysis. Second, the search tree model is presented. Third, we study the average number of nodes explored by both B&B-BFS and B&B-CD on search trees generated using the proposed model to determine the scenarios in which B&B-CD explores fewer nodes than B&B-BFS. Finally we test the effectiveness and the limitations of the conclusions from the search tree model on several problems.
The rest of this paper is organized as follows. Section 2 presents more background on the CBFS strategy. The assumptions necessary for our analysis on the B&B algorithm and the associated search trees are presented in Section 3, and a search tree model is also proposed. In Section 4 we propose a way to estimate the expected number of nodes explored by B&B-CD on the search tree model. Section 5 presents numerical results of applying B&B-BFS and B&B-CD on the search trees generated using the proposed model. The impact of nodes with different lower bounds on the performance of B&B-BFS and B&B-CD is discussed and tested on several problems, including a scheduling problem and some mixed integer programming (MIP) problems. Section 6 concludes the paper and briefly discusses future research possibilities.
